{"success":true,"data":[{"id":"5fdb44d70f99cb37f45e3410","author_id":"56f3686f02c237a73a1a8acf","tab":"share","content":"<div class=\"markdown-text\"><p>RT.</p>\n<p>请大家遵守法律法规，勿发布不合规内容。</p>\n</div>","title":"请大家遵纪守法，勿发布不合规内容","last_reply_at":"2020-12-24T05:43:55.339Z","good":false,"top":true,"reply_count":43,"visit_count":1561,"create_at":"2020-12-17T11:45:27.667Z","author":{"loginname":"thonatos","avatar_url":"https://avatars2.githubusercontent.com/u/958063?v=4&s=120"}},{"id":"5fe2b84498427e7b936a9f8c","author_id":"4f3e074762b5c6a270012916","tab":"share","content":"<div class=\"markdown-text\"><p>SEE Conf 2021将于2021年1月9日在杭州蚂蚁Z空间举办。大会网站：<a href=\"https://seeconf.antfin.com/\">https://seeconf.antfin.com/</a></p>\n<p><img src=\"//static.cnodejs.org/Fqoq48x3xvaJ2xBos5terDa948SE\" alt=\"SEE Conf 2021\"></p>\n<p>SEE Conf（支付宝体验科技大会）是由蚂蚁集团主办的，集专业分享、展台等内容于一身的科技盛筵。SEE 是 Seeking Experience &amp; Engineering 的缩写，意为探索用户体验与工程实践。我们希望通过 SEE Conf, 与业界同行一起分享交流体验科技的当前进展，探讨切磋体验科技的未来发展，共同努力促进体验设计与技术的开放，让生态繁荣共赢。</p>\n<p>2020年1月初，SEE Conf 2020在西湖文体中心成功举办， 将设计与技术相融合，配合 IMAX 大屏 + 杜比全景声音效，给与会的近千位 Developers &amp; Designers 带来了极致的体验，在知乎引发了热烈关注与讨论。</p>\n<p>一年时光仿若白驹过隙，如今我们又将迎来 SEE Conf 2021 了～</p>\n<p>SEE Conf 2021将于2021年1月9日在杭州蚂蚁Z空间举办。下面让我们来了解一下本届 SEE Conf 都有哪些看点吧～</p>\n<h2>主题 &amp; 会场</h2>\n<p>本次的主题是「探索极致用户体验与最佳工程实践」，会议时长为一天，仍以上午主会场 + 下午设计 &amp; 技术分会场的形式开展，大家可以根据自己的兴趣选听。</p>\n<p>除了主题演讲之外，现场还有丰富的展台供大家互动、我们也邀请了乐队现场表演～</p>\n<h2>重磅大咖</h2>\n<h3>辛向阳</h3>\n<p>辛向阳，教授、博士生导师，XXY Innovation创始人，卡耐基梅隆大学设计哲学博士，四川美术学院特聘教授、澳门科技大学、江南大学、天津大学兼职教授。曾任江南大学设计学院院长、香港理工大学交互设计硕士课程主任等职务。具有跨机械、建筑、平面设计、油画、交互设计以及艺术史多个学科的教育和工作背景，主要研究交互、体验、服务设计和组织创新等新兴领域，提出了“交互五要素”、“行为逻辑”、“从用户体验到体验设计”、服务设计“A-C/E-M”定位、“设计的蝴蝶效应：当生活方式成为设计对象”等交互与服务设计领域重要理论和方法。</p>\n<p>辛向阳教授策划和共同组织了交互设计国际大会、国际体验设计大会、“设计教育再设计”、TTF转型趋势论坛等重要系列国际会议；应邀作为包括GMark、IXDA、红星奖、中国优秀工业设计大奖、中国智造大奖等重要设计大赛评委；为宝洁公司总部、美国国家邮政局、香港特区政府、香港应用科技研究院、香港博爱医院、GE、华为、长虹、腾讯、震旦、三星等公司提供过多种顾问获研发服务；先后获中国工业设计十佳教育工作者、光华龙腾中国设计贡献奖银质奖章、国际交互设计协会“交互设计未来之声” 年度大奖、江苏省归侨侨眷先进个人、江苏省教学成果一等奖、国家教学成果奖二等奖、光华设计基金会中国设计贡献奖金质奖章、“改革开放40年中国设计40人”、“新中国成立七十年中国设计70人”等荣誉称号。</p>\n<p>辛向阳教授将为我们带来「动机：战略决策中的隐蔽因素」主题演讲。</p>\n<h3>玉伯</h3>\n<p>作为体验技术部的负责人，玉伯对于 SEE Conf 这个 baby 可谓关心备至，每一届都会进行「体验科技」主题分享，上一届的「体验科技与好的产品」分享启发了不少小伙伴（当然包括我啦嘿嘿）～</p>\n<p>一起期待这次玉伯带来的分享吧！</p>\n<h2>演讲主题</h2>\n<h3>主会场</h3>\n<ul>\n<li>开场主题演讲</li>\n<li>动机：战略决策中的隐蔽因素</li>\n<li>Ant Design 资产工程化探索和实践</li>\n<li>图释万物 - AntV 图可视分析解决方案</li>\n<li>你不了解的Web动画</li>\n</ul>\n<p>###设计分会场</p>\n<ul>\n<li>普惠金融下的支付宝包容性设计</li>\n<li>理财新趋势：直播让金融服务更普惠</li>\n<li>新制造场景下的设计驱动：体验直达一线</li>\n<li>多元设计做物流数字化赋能-从软硬一体到空间行为一致</li>\n</ul>\n<p>###技术分会场</p>\n<ul>\n<li>企业级前端框架与工程化实践</li>\n<li>支付宝视觉稿转代码技术探索和实践</li>\n<li>支付宝小程序体验优化实践</li>\n</ul>\n<p>更多演讲主题尽请期待！</p>\n<h3>大会门票</h3>\n<p>本次门票统一定价为 199 元，技术场与设计场同价。\n售票时间：即刻起至2021年1月 8日\nPS：由于蚂蚁 Z 空间园区容纳人数有限，门票数量有限，感兴趣的朋友请赶紧抢票哈，售完即止哟～</p>\n<p>购买门票：<a href=\"https://seeconf.antfin.com/\">https://seeconf.antfin.com/</a></p>\n</div>","title":"SEE Conf 2021 如期而至，体验科技极致美","last_reply_at":"2020-12-24T02:12:56.235Z","good":false,"top":true,"reply_count":2,"visit_count":1131,"create_at":"2020-12-23T03:23:48.009Z","author":{"loginname":"lovevfp","avatar_url":"https://avatars1.githubusercontent.com/u/285661?v=4&s=120"}},{"id":"5ee1ee83b703280f0bcb922a","author_id":"575eaa97c1518403160a45c4","tab":"share","content":"<div class=\"markdown-text\"><p>欢迎加入官方钉钉群 <strong>35149528</strong> 一起讨论</p>\n<p>如果项目对你有帮助，访问 <a href=\"https://github.com/hyj1991/easy-monitor\">https://github.com/hyj1991/easy-monitor</a> 来 star 支持下作者。</p>\n<h2>I. 项目简介</h2>\n<p>作为一名 Node.js 开发者，深知对于初涉服务端领域的前端同学来说，在引入 Node.js 的时候很容易心里没底：</p>\n<ul>\n<li>我的应用内存一点点上涨，是为什么呢？</li>\n<li>我的应用为何响应时间这么慢？</li>\n<li>我的代码性能瓶颈在那里呢？</li>\n<li>…</li>\n</ul>\n<p>今天我们很荣幸能回馈社区，正式开源 <a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a> 3.0 版本，它是一款Node.js 应用性能监控与线上故障定位解决方案。</p>\n<p>旨在 Node.js 的开源生态工具链上，做一些能帮助到想使用和正在使用 Node.js 的开发者更好地感知自己的 Node.js 应用状态，以更好地面对来自性能和稳定性方面的挑战。</p>\n<p><strong>3.0 具备以下新特性：</strong></p>\n<ul>\n<li>针对 Node.js 进程与系统指标的性能监控</li>\n<li>错误日志展示与依赖 Npm 模块安全风险提示</li>\n<li>自定义智能运维告警与线上进程实时状态导出</li>\n</ul>\n<p>对比起 AliNode 等前辈，Easy-Monitor 提供了：</p>\n<ul>\n<li>私有化部署能力。</li>\n<li>低侵入性，通过 Addon 的方式提供能力，无需定制 Node.js Runtime，能更快的跟进上游。</li>\n<li>支持 Linux、macOS、Windows 三大操作系统。</li>\n</ul>\n<p><img src=\"//static.cnodejs.org/FnEoTfjTCxChTFvTt_xIU8ko1Dnj\" alt=\"image.png\"></p>\n<ul>\n<li>文档地址：<a href=\"https://github.com/hyj1991/easy-monitor\">https://github.com/hyj1991/easy-monitor</a></li>\n<li>源码地址：<a href=\"https://github.com/X-Profiler\">https://github.com/X-Profiler</a></li>\n</ul>\n<h2>II. 整体架构</h2>\n<p>Easy-Monitor 经过了 1.x，2.x 两个大版本的功能迭代，目前的 3.0 版本是作者在 Node.js 监控侧的又一个阶段性总结，对这部分感兴趣的同学可以查看 <a href=\"https://www.yuque.com/hyj1991/easy-monitor/past-and-present\">前世今生</a>。</p>\n<p>目前实现了对 <strong>Window</strong>、<strong>Linux</strong> 和 <strong>MacOS</strong> 三大平台的 Node.js 应用监控支持，整体设计架构如下所示：</p>\n<p><img src=\"//static.cnodejs.org/FvZX-2V8QKJJKrIZHN17sbtKazI0\" alt=\"image.png\"></p>\n<p>控制台前端基于 <a href=\"https://vuejs.org/\">Vue.js</a> + <a href=\"https://github.com/view-design/ViewUI\">iView UI</a> 框架编写，监控服务端部分则是基于 <a href=\"https://eggjs.org/\">Egg.js</a> 框架编写，UI 部分整体参考了 AliNode 控制台。</p>\n<p>更多信息可以访问 <a href=\"https://www.yuque.com/hyj1991/easy-monitor/architecture\">用户手册 - 整体架构</a> 进行查看。</p>\n<p>在此，再次感谢 <a href=\"https://eggjs.org/\">Egg.js</a>、<a href=\"https://github.com/cnpm\">CNPM</a> 和 <a href=\"https://node.console.aliyun.com/\">AliNode</a> 对 Node.js 生态带来的贡献。</p>\n<h2>III. 部署指南</h2>\n<p>参照模块设计图，可以看到项目的部署主要分为两个部分：</p>\n<ul>\n<li>部署监控服务端</li>\n<li>Node.js 应用接入</li>\n</ul>\n<p>我们提供了以下 Demo 帮助大家快速体验下 Easy-Monitor 3.0 的能力。</p>\n<h3>控制台</h3>\n<p>大家可以访问 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> ，快速体验下新版。（Demo 在代码上做了一些特殊限制防止恶意操作，本地控制台部署参见下文 <a href=\"#AT5yW\">完整使用文档</a>）</p>\n<h3>应用接入</h3>\n<p>我们支持各种 Node.js 应用接入，此处以 <a href=\"https://eggjs.org/\">Egg.js</a> 为例：</p>\n<p>先安装插件：</p>\n<pre class=\"prettyprint language-bash\"><code>npm i --save egg-xtransit --xprofiler_binary_host_mirror=https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;xprofiler\n</code></pre><p>启用插件：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; {app_root}&#x2F;config&#x2F;plugin.js\nexports.xtransit = {\n  enable: true,\n  package: &#x27;egg-xtransit&#x27;,\n};\n</code></pre><p>配置接入信息：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; {app_root}&#x2F;config&#x2F;config.default.js\nexports.xtransit = {\n  server: &#x27;ws:&#x2F;&#x2F;devtoolx.com:7070&#x27;,\n  appId: 1,\n  appSecret: &#x27;f7b99d08cc0193106690860047b28970&#x27;\n};\n</code></pre><p>对应的 ID 需要访问 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> 来注册和获取，如下：</p>\n<p><img src=\"//static.cnodejs.org/FvG9ApruCc5ADFoXMLwh-ui77t17\" alt=\"image.png\"></p>\n<p>最后按照正常操作启动 Egg.js 项目即可，正常情况下，你可以在 <a href=\"http://www.devtoolx.com/easy-monitor\">控制台 Demo</a> 主页看到本地连接上来的实例：</p>\n<p><img src=\"//static.cnodejs.org/FtVey-27T8znhlQnbINeGp_zw048\" alt=\"image.png\"></p>\n<h3>用户手册</h3>\n<p>目前完整的使用文档部署在语雀上，参见 <a href=\"https://www.yuque.com/hyj1991/easy-monitor\">Easy-Monitor 3.0 用户手册</a>。</p>\n<p>开发者可以根据文档自行部署上述的监控服务端，再将自己的 Node.js 应用接入。</p>\n<h2>IV. 支持作者</h2>\n<p>最后的最后，作者是完全使用空余时间维护更新这个项目的，如果项目对你有帮助， 来个 <a href=\"https://github.com/hyj1991/easy-monitor\">star</a> 支持下作者吧 :)</p>\n<p>如果你在使用过程中有任何的疑问或者建议可以提 issue，或者扫码加钉钉群联系作者：</p>\n<p><img src=\"//static.cnodejs.org/FovdVuTHR8dqbNQA2G3WUX8dt93P\" alt=\"微信图片_20200717085956.jpg\"></p>\n<p>希望本项目如其名一样，能帮助开发者解决更多开发中遇到的问题，构建起对 Node.js 技术栈的信心，让 Node.js 更加 “简单”。</p>\n</div>","title":"Easy-Monitor 3.0 开源 - 基于 Addon 的 Node.js 性能监控解决方案","last_reply_at":"2020-12-21T20:00:37.757Z","good":true,"top":true,"reply_count":26,"visit_count":70207,"create_at":"2020-06-11T08:42:43.597Z","author":{"loginname":"hyj1991","avatar_url":"https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"}},{"id":"5efb4c5d13f8b244e57cc632","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FtqTjdKjmFfToaLhm5Lvn8YI0c0E\" alt=\"nodejs_interprise_practice.png\"></p>\n<p>在和一些 Nodeer 童鞋的分享交流过程中，也会听到一些声音：“Node.js 在企业中是如何应用的？有哪些大厂在实践？”，于是公众号 “Nodejs技术栈” 自 19 年 8 月开始陆陆续续给大家分享一些 Node.js 在企业中的应用实践，希望给正在学习、使用 Node.js 的童鞋一些参考。</p>\n<p><strong>Nodejs 生态的建设需要大家共同努力，如有企业实践的欢迎补充让更多朋友能够看到</strong>！谢谢大家！</p>\n<h2>阿里</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/63Lv9qwsoXocCE3sIhsIPA\">看优酷 Nodejs 重构之路 Serverless SSR 未来可期</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/101917567\">“云”端的语雀：用 JavaScript 全栈打造商业级应用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/f5xIN9d7s011_gXej84MJw\">独家解读：淘宝使用 Node.js 的 TypeScript 多场景开发和实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ghciI1dj9dve6Bsrf8Yj1w\">基于阿里云的 Node.js 稳定性实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/wIYlSPSJSK2eHbk48SFQLw\">蚂蚁金服 Node.js 开荒史 - 摸爬滚打才不负功名尘土</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/oKcQXj3CWt1Ts_tOtw7QTg\">基于 Node.js 的 Serverless 架构实践</a></li>\n<li><a href=\"https://www.yuque.com/preview/yuque/0/2020/pdf/84135/1578575086211-802410a9-a833-47ce-b612-b6f6108285e6.pdf\">用 Node.js 构建海量页面渲染服务</a></li>\n<li><a href=\"https://www.yuque.com/preview/yuque/0/2020/pdf/84135/1578577070295-d62924f6-a34c-463f-a6b5-ea657cfd038d.pdf\">Node.js Web 框架研发与实践</a></li>\n<li><a href=\"https://github.com/tmallfe/tmallfe.github.io/issues/28\">天猫双11前端分享系列（四）：大规模 Node.js 应用</a>（上）</li>\n<li><a href=\"https://github.com/tmallfe/tmallfe.github.io/issues/30\">天猫双11前端分享系列（六）：大规模 Node.js 应用（续）</a>（下）</li>\n</ul>\n<h2>腾讯</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/7lA2-mCM9GR3BekWH6hB2Q\">腾讯视频 Node.js 服务是如何支撑国庆阅兵直播高并发的？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/GGrb7Oex7SqtwzIKAXSFVg\">Node.js 部署和运维工作量降低 80%，腾讯 NOW 直播是怎么做到的？</a></li>\n</ul>\n<h2>携程</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/yuK3MvgMlYE5thEx6e8rtQ\">浅谈 Node.js 在携程的应用</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/NU7Hm96-cngvUCOF2LOpMA\">携程机票 Node.js 开发实践</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/ndPlZJWM9pxusGMY8C0eyA\">Node.js 在携程的落地和最佳实践</a></li>\n</ul>\n<h2>转转</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/1rjvoOySe-dcxn8fWE8BMQ\">Node.js 在转转的微服务实践（一）</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/HyoCCOD0SqcGA7Ajt7GWuA\">Node.js 在转转的微服务实践（二）</a></li>\n</ul>\n<h2>宋小菜</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/HCKWKhnlDwAGo5s797W7jA\">框架设计：如何基于 Egg 设计 Node 的服务框架</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/j4tAMFzlGQ5O9q768KE9Cg\">为什么 Node 是小菜前端团队的核心技术栈</a></li>\n</ul>\n<h2>百度</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/2ZnBR2Ki7VJCLmtVT4oOsw\">商业化场景下，百度如何实践 Node.js 架构？</a></li>\n</ul>\n<h2>苏宁</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/Dr7k1JDE6crJoYU7fmEcTw\">苏宁的 Node.js 实践：不低于Java的渲染性能、安全稳定迭代快</a></li>\n</ul>\n<h2>京东</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/jnIqOr-zhybgZbejKLZikg\">记一次京东 Node.js 直出服务的性能优化</a></li>\n</ul>\n<h2>爱奇艺</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/J9cYX8DkZFb6iAJt6E0THQ\">爱奇艺 PC Web Node.js 中间层实践</a></li>\n</ul>\n<h2>去哪儿</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/osgtwTLJhJJmF0bHFmKgUg\">去哪儿网前后端分离实践（含 Node.js 应用实践）</a></li>\n</ul>\n<h2>个推</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/e_w0Q1T1F8yZWHeoUaOTQw\">Node.js 在个推的微服务实践：基于容器的一站式命令行工具链</a></li>\n</ul>\n<h2>有赞</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/vTL98USoRyJrcu4ny9r0ZQ\">Node.js 在有赞的实践分享</a></li>\n</ul>\n<h2>微医</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/OeZyo7MZhadGjKV83LZnhA\">Node.js 在微医的应用场景及实践</a></li>\n</ul>\n<h2>贝壳找房</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/umr-SZXflTy9XQoRRf56Rg\">2019大前端秘籍：贝壳找房多端提效和性能质量优化实践</a></li>\n</ul>\n<h2>途牛</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/TI8VgCpToFQDrITLyac3Rg\">Node.js 微应用在途牛的实践</a></li>\n</ul>\n<h2>滴滴</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/IsnQCEC8oehDmdmpbXWKwQ\">NodeX Component - 滴滴集团 Node.js 生态组件体系</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/x62tkL5bUgbBaRyNwRgxNw\">滴滴 NodeX 生态</a></li>\n</ul>\n<h2>58 同城</h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/wfMl-2wFXSpx8QjTckJxCw\">基于 SFF 一站式 Nodejs 服务管理平台实践</a></li>\n</ul>\n<h2>网易</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/138925672\">网易智慧企业 Node.js 实践（1）| Node 应用架构设计和 React 同构</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/142547821\">网易智慧企业 Node.js 实践（2）| 平滑发布和前端代码</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/142551285\">网易智慧企业 Node.js 实践（3）| 灰度环境和应用监控</a></li>\n</ul>\n<h2></h2>\n<hr>\n<p>如果您正在实践 Node.js，很期待能收到您的分享，可以关注公众号 “Nodejs技术栈” 在后台向我投稿，后期都会进行整理放在 <a href=\"https://github.com/Q-Angelo/Nodejs-Roadmap/blob/master/docs/nodejs/practice/enterprise.md\">Github</a> 以供大家学习和实践参考。</p>\n<p><strong>作者简介</strong>：五月君，软件设计师，<a href=\"https://www.imooc.com/u/2667395\">慕课网认证作者</a>，公众号 “<a href=\"https://nodejsred.oss-cn-shanghai.aliyuncs.com/node_roadmap_wx.jpg?x-oss-process=style/may\">Nodejs技术栈</a>” 作者，热爱技术、喜欢分享的 90 后青年，欢迎关注 Github 开源项目 <a href=\"https://www.nodejs.red\">https://www.nodejs.red</a></p>\n</div>","title":"Node.js 在企业中的应用实践集锦 - 2020 年中汇总","last_reply_at":"2020-10-04T12:59:45.432Z","good":true,"top":true,"reply_count":17,"visit_count":63922,"create_at":"2020-06-30T14:29:49.729Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5e16978581adfe260207a8c1","author_id":"54009f5ccd66f2eb37190485","tab":"share","content":"<div class=\"markdown-text\"><h2>活动信息</h2>\n<p><img src=\"//static.cnodejs.org/Fsqzwb41k7ivzIJn810EEwPQ_2it\" alt=\"1111.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu_XCoMAB8uUlFYPGWQ3ncssCb8t\" alt=\"2222.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fge-hr_LF_guf0BbwQ9xmi0unnNi\" alt=\"33333.png\"></p>\n<p>本次活动需要提前报名，场地大约有100人</p>\n<p>报名连接</p>\n<p><a href=\"https://www.huodongxing.com/event/5526816284100?utm_source=%E5%8F%91%E7%8E%B0%E6%B4%BB%E5%8A%A8%E9%A1%B5&amp;utm_medium=&amp;utm_campaign=eventspage\">https://www.huodongxing.com/event/5526816284100?utm_source=发现活动页&amp;utm_medium=&amp;utm_campaign=eventspage</a></p>\n<h2>PPT</h2>\n<p><a href=\"https://github.com/i5ting/nodeparty-beijing-2020-1-11\">https://github.com/i5ting/nodeparty-beijing-2020-1-11</a></p>\n<h2>照片</h2>\n<p>龙佳文\n<img src=\"//static.cnodejs.org/Fg4dIjPNKksKiOMmyIgGMEg1087O\" alt=\"111 1.jpg\"></p>\n<p>十忆\n<img src=\"//static.cnodejs.org/Fs9J2dxbgickUDOzM7Vwuxd7HVKF\" alt=\"222 1.jpg\">\n狼叔\n<img src=\"//static.cnodejs.org/Fhc9AmVNEbqAdmxOUTYwIN7XdYU_\" alt=\"3333 1.jpg\">\n王东\n<img src=\"//static.cnodejs.org/FssLOS3hMlVq658eD_yb3CJpeW8C\" alt=\"4444 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fsuj39b-PoVOS65vAoVgFqbR9m8Q\" alt=\"5555 1.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiTD21bRAzZZbpCueJRk7Uq-Ik7i\" alt=\"7777 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/Fm6ssdq_P6JNaftwAZ_AyiXtVIxb\" alt=\"8888 1.jpg\">\n流司\n<img src=\"//static.cnodejs.org/FoqgjwSNssTlJ1ufnowc1jxx_imR\" alt=\"9923 1.jpg\">\n现场提问\n<img src=\"//static.cnodejs.org/FplNNONJOacRNbvnvc7EBl1sgN8U\" alt=\"9999 1.jpg\">\n现场\n<img src=\"//static.cnodejs.org/Fl--jBm9nfRCmNPCvL92TrlkvdGT\" alt=\"11212 1.jpg\"></p>\n<p>圆桌会\n<img src=\"//static.cnodejs.org/Fq7xH6d9K1bor6ixUFY1AEO4d8GU\" alt=\"23323e4ds 1.jpg\">\n<img src=\"//static.cnodejs.org/FulUvueqoTJ8nIGlOgJTD1JFGDPA\" alt=\"322332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Ftw6oRg8G-eeqQ2SLrwiaj671sMF\" alt=\"稳稳稳.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FozWsIovHilxYBlJ-I8LmYW-gNhi\" alt=\"32323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fvhek3xeqE4afj41AuB5Vuj7MwSr\" alt=\"43434.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FvM4WhrhpkRT9sZ3CxsbGy8OX7bH\" alt=\"55545.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fh7MgA9zXpT3Gc-1UfXsd3o8FB6F\" alt=\"111110.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fr6oow-uHpFkkoVo2xIaw3Xm-gdI\" alt=\"232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fl3A1Ijt8IeE9XHT9DNNUM_I0OkB\" alt=\"232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FobbWO7B2JwwszK80ZpJT8Pl6f0Y\" alt=\"322323.jpg\">\n<img src=\"//static.cnodejs.org/Fr7qQvzHT6pLInnX9m6JeFZEjKYC\" alt=\"812312.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FinFnUdjTZjt2DAdjC5H-DsYZ4Fa\" alt=\"882323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fq-nKPQt4JeiBZAQKft6vW49pGiB\" alt=\"3434389.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FuAt3QuZ-Y9E21EMrkn05JAcPLsf\" alt=\"9999923.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FkpIr82doXBBk7VH1aGM6zD16qZ-\" alt=\"23323232323.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FiKYZ46Ilm5OVT_Tunhmga8x-vrr\" alt=\"232323232332.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FqOE05r204gsYDWp-m9p04Vf1ME_\" alt=\"aaa.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FmRRAzINYs-j5hF-n7-LZKscD23e\" alt=\"bbbb.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FjIIelIuczqPkJjWSKC5wEtv3uzD\" alt=\"cccc.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FtponmJNP2UD0qemwD_1vBBa0ibK\" alt=\"dddd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fv0LVdt1X6RizMg5gp2CerH1pIMH\" alt=\"dfdfd.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/Fgw6rAtxlJg9fWLlQNM4gwozWlVj\" alt=\"eeeee.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FlnX4CFVmxrFQXmNWYQuwt6Ar4Et\" alt=\"EmptyName 2.jpg\"></p>\n<p><img src=\"//static.cnodejs.org/FnnoaFaMof3IxOR9sWJIj6jrjcPx\" alt=\"hjkl;'.jpg\"></p>\n<p>王东\n<img src=\"//static.cnodejs.org/FhNqWIas9yk1XuYvNHtijUzB40BK\" alt=\"jhklsd.jpg\"></p>\n<p>嘉宾合影\n<img src=\"//static.cnodejs.org/FvKMqpc7UZhVeRKXUNvtY8FuBAEh\" alt=\"上3.jpg\"></p>\n<p>狼书签名\n<img src=\"//static.cnodejs.org/FgxEWL85ZMEA8qpVakAvvSUWEmVd\" alt=\"23e4232 1.jpg\"></p>\n<h2>视频</h2>\n<p>面向B端工作台的微前端方案-ConsoleOS-徐博文\n<a href=\"https://edu.talkingdata.com/open-class?id=142\">https://edu.talkingdata.com/open-class?id=142</a></p>\n<p>Serverless在美团的实践-龙佳文\n<a href=\"https://edu.talkingdata.com/open-class?id=143\">https://edu.talkingdata.com/open-class?id=143</a></p>\n<p>前端生态建设在瓜子的落地实践-王东\n<a href=\"https://edu.talkingdata.com/open-class?id=144\">https://edu.talkingdata.com/open-class?id=144</a></p>\n<p>Egg-React-SSR深度解析-张宇昂\n<a href=\"https://edu.talkingdata.com/open-class?id=145\">https://edu.talkingdata.com/open-class?id=145</a></p>\n<p>如何融入并贡献开源-Justjavac\n<a href=\"https://edu.talkingdata.com/open-class?id=146\">https://edu.talkingdata.com/open-class?id=146</a></p>\n<p>圆桌讨论\n<a href=\"https://edu.talkingdata.com/open-class?id=147\">https://edu.talkingdata.com/open-class?id=147</a></p>\n</div>","title":"2020年1月11日Node party@北京成功举办，附照片、视频和ppt","last_reply_at":"2020-09-28T03:40:52.790Z","good":true,"top":true,"reply_count":14,"visit_count":58743,"create_at":"2020-01-09T03:01:25.190Z","author":{"loginname":"i5ting","avatar_url":"https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"}},{"id":"5fe1ba0898427e56506a9d9b","author_id":"59f67da6323d3667540dad94","tab":"share","content":"<div class=\"markdown-text\"><p>今天接了一个需求，要求去操作一个已打开的浏览器，执行相关的自动化脚本，原理则是根据调试端口通过webdriver调试浏览器。\n这里面比较特别的是它使用的是基于chromium的非常规浏览器，需要手动调用浏览器驱动。\n在这里分享一下，希望对未来踩坑的同学有帮助，顺便请教一下用puppeteer是否可以完成这些？</p>\n<pre class=\"prettyprint language-js\"><code>const webdriver = require(&#x27;selenium-webdriver&#x27;)\nconst chrome = require(&#x27;selenium-webdriver&#x2F;chrome&#x27;)\nconst path = require(&#x27;path&#x27;)\n\nasync function main() {\n    const options = new chrome.Options()\n    options.options_[&quot;debuggerAddress&quot;] = &quot;127.0.0.1:8800&quot;;\n\n    const service = new chrome.ServiceBuilder(path.join(__dirname, &#x27;.&#x2F;chromedriver.exe&#x27;)).build()\n    chrome.setDefaultService(service)\n\n    const driver = new webdriver.Builder()\n        .setChromeOptions(options)\n        .withCapabilities(webdriver.Capabilities.chrome())\n        .build()\n\n    await driver.get(&#x27;https:&#x2F;&#x2F;www.baidu.com&#x27;);\n}\n\nmain()\n</code></pre></div>","title":"用selenium控制已打开的浏览器","last_reply_at":"2020-12-24T06:24:36.501Z","good":false,"top":false,"reply_count":3,"visit_count":104,"create_at":"2020-12-22T09:19:04.647Z","author":{"loginname":"linliny","avatar_url":"https://avatars0.githubusercontent.com/u/24646739?v=4&s=120"}},{"id":"5b0fc85b5cd02be640901047","author_id":"5b094f5257137f22415c4685","tab":"share","content":"<div class=\"markdown-text\"><h1>翻墙与科学上网，中国VPN推荐</h1>\n<p>本文总结<a href=\"https://www.wallmama.com\">翻墙与科学上网工具</a>，介绍VPN，蓝灯、SSR等翻墙软件。免费VPN，免费SSR我就不推荐了，付费VPN中国能用的越来越少，何况免费的。现在没有让你一劳永逸的翻墙工具，也没有完美的科学上网，即使是ExpressVPN也只能做到大概全年97%连通率，个人经验，其它工具更做不到100%。个人建议普通用户用VPN翻墙，本文也优先作中国VPN推荐，非果粉用蓝灯也行。懂技术的人可以考虑SSR，付费SSR节点长期更靠谱。</p>\n<p>每年的春节、三月初、六月初、国庆期间、某些突发事件时期都是“<strong>敏感时期</strong>”，基本上在中国使用的所有科学上网工具都会出现频繁断线、连接超时，速度大幅下降等问题，每次持续1-2周左右，过后自动恢复。如果你的学习工作高度依赖国外网站或App，建议提早多准备几个工具，个人经验是VPN+蓝灯+SSR三者的组合基本上可以帮你度过敏感期。非重度翻墙用户如果不想折腾多款工具的，不妨等几天网络恢复，因为其它也没有什么更好的办法。</p>\n<p><strong>这是本文推荐的中国能用的VPN速览：</strong></p>\n<ul>\n<li>1 <a href=\"https://indx.cc/expcnd\">ExpressVPN</a>：什么都不需要说，我自己用了5年多，市场上最强跨设备通用翻墙软件</li>\n<li>2 <a href=\"https://indx.cc/pandavpn\">PandaVPN</a>：新出的服务，目前工作良好，其实<strong>不是VPN而是加密代理</strong></li>\n<li>3 <a href=\"https://indx.cc/astrillcn\">AstrillVPN</a>：低调的厂商，但其实中国一直能用，在中国的老外很多都用这个</li>\n<li>4 <a href=\"https://indx.cc/vyr\">VyprVPN</a>：兢兢业业为中国翻墙者服务，不是最强大的，但能用</li>\n</ul>\n<p><strong>最后更新：2019年11月</strong></p>\n<p><code>列表可能随时变化，可以收藏本帖，保持关注。</code></p>\n<p>不要期望单个工具能保证100%连通率，至少每年敏感时期绝对是做不到的。如果你追求全年100%连通率，需要一个工具组合，我自己的组合是：\n<a href=\"https://indx.cc/expcnd\">ExpressVPN - 基于VPN协议</a> + 蓝灯（或<a href=\"https://indx.cc/pandavpn\">PandaVPN - 第三方加密代理服务</a>） + <a href=\"https://indx.cc/vtr\">自建SSR - 较私密的加密代理</a>，基本上前两者就可做到99.5%+的连通率。</p>\n<h1>翻墙软件比较</h1>\n<p>主流翻墙软件目前就两大类：一是VPN（OpenVPN等多种协议），二是加密代理（HTTPS，SOCKS5），蓝灯和SSR技术上都属于代理类，VPN、蓝灯、SSR各自都有优缺点。</p>\n<h2>VPN</h2>\n<h3>优点</h3>\n<ul>\n<li><strong>中国政府的政策上留有空间</strong>，特别是OpenVPN协议在商业环境下的广泛使用，使得网络<a href=\"https://zh.wikipedia.org/zh-hans/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E\">防火墙</a>无法在协议级别实现完全屏蔽</li>\n<li>成熟、通用，设备支持更全面，特备是针对路由器等中间网络设备的支持较强，在某些使用场景下没有VPN无法替代</li>\n<li>个人终端客户端使用友好，基本无需配置，装好就能用，升级全自动</li>\n<li>节点选择多，商业VPN的服务器遍布全球，虽然绝大部分都不适合中国，但周边的香港、日本等地的服务器集群也足够用</li>\n</ul>\n<h3>缺点</h3>\n<ul>\n<li>传输开销相比代理类协议（如SOCKS5）大，一般认为VPN的连接与传输速度也相对慢一点</li>\n<li>受打击力度大，国内的服务基本全军覆没，国外的服务能用已经不多，选择越来越少</li>\n<li>供求关系失衡决定了VPN相对自助翻墙方法成本往往更高</li>\n<li>达不到全年100%可用标准，至少我还没找到一年365天都能连上的VPN，特殊时期必挂，一般持续约一周</li>\n</ul>\n<h2>蓝灯</h2>\n<h3>优点</h3>\n<ul>\n<li>基于SOCK5协议，建立连接快，传输开销比VPN小</li>\n<li>是商业软件，相比SSR有更好的客服支持</li>\n<li>有设计良好，好用的客户端</li>\n</ul>\n<h3>缺点</h3>\n<ul>\n<li><strong>不支持iOS设备</strong></li>\n<li>只支持自动连接，不适合需要手动控制连接IP的场景</li>\n<li>隐私保护能力较一线VPN弱</li>\n</ul>\n<h2>SSR</h2>\n<h3>优点</h3>\n<ul>\n<li>可以选择用商业SSR节点，也可以自己架设，相比VPN更灵活</li>\n<li>自建SSR服务器，能用的概率比自建VPN服务器能用的概率大很多</li>\n<li>商业节点或自建服务器硬件要求不高，所以扩展容易、成本低</li>\n<li>因为基于SOCKS5协议，连接快传输开销相比VPN小，效率高</li>\n</ul>\n<h3>缺点</h3>\n<ul>\n<li>协议开源，长期来说被GFW团队攻破是迟早的事，其实不完全攻破只需解析出流量特征，SSR的死期也就到了</li>\n<li>缺乏成熟的一体化、友好的部署方案，服务器安装需要一定手动配置，客户端界面可用性比商用VPN软件也还有距离，所以目前SSR主要在电脑技术人员群体中流行</li>\n</ul>\n<h2>总的来说</h2>\n<p>传统VPN协议因为在商用中高度普及这个非技术原因，完全屏蔽的可能性更小，目前个人用VPN产品在中国能用的虽然已经很少，绝大多数国外VPN厂商也不再投资中国市场，但市场上仍有若干能有效翻墙的VPN，这些商用VPN的客户端的设备支持仍然是最全的，可用性也是最高的。</p>\n<p>蓝灯的稳定性和速度都还行，但最大的缺点是没有iOS版客户端，蓝灯自带广告过滤功能，用处不算太大，但聊胜于无，蓝灯不能手选连接节点，只能自动连接，既方便也不方便，如果用户需要用可控的IP地址，建议用付费VPN吧。</p>\n<p>SSR的最大优势是可选择的VPS不少，挪窝比较容易，缺点是对技术小白不友好，安装配置不算难，但也足以难道大多数普通翻墙用户，而且<strong>SSR在价格上其实未必比VPN便宜多少</strong>。这里不建议复用网站主机做SSR节点，IP被封后会导致网站本身也无法访问。</p>\n<h1>你该用哪种翻墙软件</h1>\n<p><strong>如果翻墙的体验对你很重要，你也不在乎稍微多花点钱</strong>，可以优先考虑一线的付费VPN，<strong>本文下文有好用的中国VPN推荐</strong>。它们都有独立开发的加密混淆技术，穿墙能力很强。这是需要长期投入的技术，免费VPN和绝大多数小付费VPN厂商都没这个预算和技术实力，它们的产品缺乏独立的加密混淆算法，在防火墙的DPI（Deep Packet Inspection）强力侦测面前不堪一击。只有一线VPN厂商才能让你在中国长期稳定地翻墙。绝大多数情况下，买一个靠谱的VPN软件就够你绝大多数时候翻墙用了。</p>\n<p><strong>如果是非iOS用户，也可以考虑蓝灯</strong>，它分为免费版和付费版（Pro），免费版提供每月500Mb的数据流量，客户端大多数时候都可以从Github页面下载。付费版的价格比一线VPN稍便宜，可以从客户端内购升级，付款也不麻烦。不过个人使用的经验，2019年后，蓝灯在中国的翻墙能力有大幅下降，我无法保证在你所在的地区网络上它能有多好用，你可以先试试免费版。</p>\n<p><strong>程序员群体，喜欢自己配置不怕折腾的，可以考虑SSR</strong>，免费SSR节点我不推荐，可以考虑自架或者用购买SSR帐号，现在提供商业SSR节点的第三方越来越多。私有的SSR服务器（多为自架）在敏感时期的穿墙能力可能更强，虽然这也不是100%但私人服务器只要不被侦测到流量特征，更难进入防火墙IP黑名单。<strong>友情提醒：不要散播自架SSR节点。</strong> 除SSR以外，V2Ray，WireGuard，Brook，VMess等翻墙技术也在兴起中，目前来看还比较小众，笔者还没用过这类工具，所以也无从判断它们好不要用，不过这类工具的配置比SSR可能还要复杂，更不适合普通用户。</p>\n<h1>你应该规避的翻墙软件</h1>\n<h2>国内VPN</h2>\n<p>大多数国内VPN都被强制关闭了，但也有的还在以“加速器”的名义在这个不确定的市场里运营着，据我所知，有少数几个还通过了政府审核。<strong>这些国内VPN主要面向游戏玩家群体</strong>，提供游戏加速服务的比较多，官网上也绝不会出现“翻墙”二字。笔者没有用过国内VPN，自从几年前Green VPN被强制关停导致很多用户“放弃退款”以后，我就不再考虑国内VPN服务了，不可抗力下服务终止的风险太大，个人用户容易蒙受损失。我现在只用国外VPN。</p>\n<h2>免费VPN</h2>\n<p>个人不推荐免费VPN。不是说它们没用，其实不少都能用，至少拿来查收个Gmail没问题。我担心的还是首先是隐私，其次是长期稳定性问题。事实上免费VPN很少披露隐私政策，即使披露也难以让人相信，天下没有免费的午餐，网络服务提供商贩卖用户隐私赚钱不是新闻。另外，我还从没用到过哪个免费翻墙工具很稳定速度很快的，最多也就是开始用的时候还行，但很快随着免费用户的快速增加，服务质量会直线下降。</p>\n<p>如果你就是在找免费VPN，百度里基本是搜不到免费VPN的，谷歌可以搜到不少，只是搜到的绝大多数用不了，也有少数能用，此外，安卓官方市场里有很多免费VPN，可以试试，苹果官方（美国）市场也是，如果你的手机能访问这些App应用市场的话。国内大多数手机既没有装Google Play Store，也没有苹果美国市场帐号，所以会比较麻烦。有的APK是可以从第三方市场下载的，可以试试，这个方法能帮你省钱，但很费时间。</p>\n<h2>破解VPN</h2>\n<p>不要相信什么破解VPN，因为VPN软件都分客户端和服务器端，破解了客户端有什么用呢，服务端算法、服务地址等都会变，破解的客户端机会无法自动获得这些更新，能也往往无法和服务器端同步使用。破解版软件很容易被挂马，带病毒，给你的电脑手机系统带来风险。</p>\n<h1>好用的中国VPN推荐</h1>\n<h2>1. <a href=\"https://indx.cc/expcnd\">ExpressVPN</a> - 现在买一年送3个月，30天无理由退款</h2>\n<p><strong>上次测试：2019年11月20日，确定可用。</strong></p>\n<p><code>缺点：一年约97%的连通率，不要期望100%，抱歉。但是，也不要期望哪个工具能做到100%，反正我还没找到</code></p>\n<p>这是最好用的中国VPN，笔者每次回国必备，用了5年，虽然特殊时期也碰到问题，但一年中97%的时间里使用都很流畅。<strong>ExpressVPN已经为中国网民服务了11年。</strong> 这是目前唯一一个任何人想都不用想就可以买的VPN，连通率应该是最高的，速度相比其他VPN软件也不慢，镜像网站更新最及时，隐私保护技术最好，还有最重要的，客户端最好用，设备支持它最全。</p>\n<p><img src=\"https://static.cnodejs.org/Fr5H3c5kz8SZc4bxAETEbWbIo7rQ\" alt=\"ExpressVPN翻墙软件.jpg\"></p>\n<p><strong>为什么ExpressVPN是最好用的中国VPN翻墙软件？</strong></p>\n<p>因为他重视中国市场。</p>\n<p>世界上的VPN软件成千上万，愿意为中国用户提供镜像站的一只手数得过来，<a href=\"https://indx.cc/expcnd\">ExpressVPN的镜像站</a>对中国用户始终保持着可访问。</p>\n<p>客户端好用的VPN不少，但提供无需Google Play Store和苹果美国商店即可安装客户端的VPN厂商，恐怕ExpressVPN是仅有的几家之一。</p>\n<p>推荐香港、日本、新加坡、美国节点，提供国内能打开的镜像站，<a href=\"https://indx.cc/expcnd\">不翻墙即可购买</a>，真正全终端覆盖，电脑（Windows，MacOS，Linux），手机（安卓，iOS：iPhone，iPad），路由器，游戏主机（PS2，XBox）等，安卓手机无需Google Play也可安装，iOS设备无需访问苹果商店也可安装，同时5台设备，单独配置哪些应用走VPN哪些不走（Split Tunneling） ，<strong>买一年送3个月，30天无理由退款</strong>，<a href=\"https://indx.cc/expcnd\">买一年送3个月</a>，支持支付宝付款，支持P2P下载，不限流量。</p>\n<h2>2. <a href=\"https://indx.cc/pandavpn\">熊猫VPN</a></h2>\n<p><strong>上次测试：2019年11月20日，确认可用。</strong></p>\n<p><code>缺点：运营时间还比较短，只支持同时3个连接，且不支持路由器和Linux，缺乏自动重连等职能功能。</code></p>\n<p>VPN的后起之秀，正在促销，<strong>买一年送一年</strong>，服务器亲测可用，而且很快。产品运营时间还不长，处于推广阶段，价格优惠幅度很大。</p>\n<p>支持Windows，Mac，iOS，Android客户端。连接VPN只需要一个开关即可。界面极其简洁，同时3台设备，这是一个让人惊喜的发现，支持智能分流。</p>\n<p><strong>虽然熊猫VPN远没有<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>强大，如客户端支持远没有ExpressVPN丰富，同时也只支持3个连接，官方也不披露日志政策</strong>，但对不少人也应该日常够用。从客户端来看，熊猫VPN背后可能不是VPN翻墙技术，而是用了类似SSR的某种加密代理，这无法确定，但是能用最重要。</p>\n<p><img src=\"https://static.cnodejs.org/FnIjvxtTcX6dVtrutkuJr9LbyTwK\" alt=\"熊猫VPN.jpg\"></p>\n<h2>3. <a href=\"https://indx.cc/astrillcn\">Astrill</a> (该链接需翻墙打开)</h2>\n<p><strong>上次测试：2019年11月20日，可用</strong></p>\n<p><code>缺点：价格贵，国内须翻墙才可购买，过于低调。</code></p>\n<p>几年前Astrill是流行的中国VPN，后来墙高了以后，给大家的感觉是Astrill彻底退出中国市场了，从某种意义上来说却是如此，但其实Astrill一直都是中国能用的VPN之一，只不过官方已经停止了任何针对中国市场的营销，你在国外各中文网站上也极少看到对Astril VPN的推荐，而且目前从国内貌似无法直接买到它，所以上面的链接需要翻墙才能访问，不得不说这使得Astrill对绝大多数中国翻墙网民来说不友好了。</p>\n<p>但也有例外。如果你此刻人在国外，打算回国探亲或者工作，可以提前在国外买好Astrill带回国使用；如果你在国内但已翻墙，也可以考虑购买Astrill。它其实一直都能用，只是特别低调而已。</p>\n<p><img src=\"https://static.cnodejs.org/Ft7eMjG0ylr5Wy2n429oBBKpqngC\" alt=\"astrillvpn.jpg\"></p>\n<h2>4. <a href=\"https://indx.cc/vyr\">VyprVPN</a></h2>\n<p><strong>上次测试：2019年11月20日，确定可用。</strong></p>\n<p><code>缺点：中国必须用变色龙版本，但这个版本不支持iOS。</code></p>\n<p><strong>记得一定要购买高配（较贵）的那个，低配的不包含变色龙协议，中国用不了。很可惜高配版不提供iOS客户端，如果你要iOS翻墙，建议还是买ExpressVPN吧。使用的时候，务必在配置里打开变色龙协议，否则是连不上的。</strong></p>\n<p>推荐台湾、韩国，香港、日本、新加坡、美国等地节点，不用翻墙国内可以购买，独家变色龙混淆协议 ，同时5台设备，30天无条件退款，支持支付宝付款，支持P2P下载，不限流量。</p>\n<p>VyprVPN是我确定中国能用的VPN软件，台湾、韩国的节点出奇地快。VyprVPN的价格低于ExpressVPN，对于觉得ExpressVPN太贵的用户，我推荐你用VyprVPN。</p>\n<p>一分钱一分货，VyprVPN的设备支持，可用节点少（对中国用户）没有ExpressVPN强大。</p>\n<p><img src=\"https://static.cnodejs.org/FumhaSBjheocx1WZT-DYjMc_HewW\" alt=\"vyprvpn.jpg\"></p>\n<h1>在中国使用VPN的几个问题</h1>\n<h2>VPN购买</h2>\n<p>一线VPN如ExpressVPN都能直接从国内直接买到，不必先翻墙。</p>\n<p>主流VPN厂商都至少支持支付宝，很多也支持银联，有人可能担心用国内支付方式会泄露个人信息。如果你从国内vpn厂商哪里购买，很有可能，但国外vpn厂商不受中国法律监管，而且国外vpn厂商对账单抬头都做了处理，即使不处理也不必担心，中国vpn用户至少几百万，只要你不提供分发下载，个人平时正常上网学习是没问题的。支付都是和个人信息绑定的，除非你用比特币支付，否则现行金融系统中的任何交易都可以被追踪，用支付宝和信用卡的可追溯性是相同的，既然如此，不必杞人忧天。</p>\n<p>有些vpn厂商提供免费试用，有的要绑定信用卡，有的不需要，如果要绑定信用卡，也不用过分担心，通常你注册的账号里都会有“取消订阅”的功能，如果没有，也可以联系客服，让他们帮忙取消。更多的厂商提供的是无条件退款服务，vpn购买者对产品有任何不满意，都可以要求退款，通常这需要联系客服或使用官方提供的其他联系方式，退款一般需要几天到账。</p>\n<h2>服务器选择</h2>\n<p>香港到大陆的ping值是最低的（小于100ms），如果软件提供，应该是最优质的翻墙节点。日本（100ms至200ms之间），美国（200ms以上），新加坡（200ms以上），都是连接稳定速度较好的VPN节点。提供台湾节点和韩国节点的VPN不多，我自己的感觉，连上的时候很快，但经常连不上，不知道什么原因。</p>\n<p>如果VPN有自动推荐最快服务器功能，多数情况只要用它推荐的就可以了。在特殊时期，近中国大陆的香港、日本节点连通率低，这时候美国、英国，甚至澳洲的连通率反而高，可以优先试试。</p>\n<h2>断线怎么办</h2>\n<p>没有100%稳定的VPN，每年特殊时间段（如六月初）的连接质量都不好，容易断线，这不是某个VPN的问题，所有的翻墙软件都会这样，一般到六月中就会完全恢复。</p>\n<p>日常使用，偶尔断线，换服务器重连即可。</p>\n<p>即使是同一个服务，在一天不同时段，或在不同地域访问，服务质量也会不同，如果你带着小飞机全国各地跑，也是一样，这是由当地网络状况决定的。</p>\n<p>网上说的什么某个VPN软件看<a href=\"https://www.youtube.com\">油管</a>一年365天一天24小时都能1080P，是不可信的。但一线VPN让你连上能稳定流畅地观看720P的视频应该没问题。</p>\n<h2>敏感时期如何度过</h2>\n<p>个人经验。<strong>这时候香港、日本等近中国大陆的节点连通率会很低，反而美国、英国，甚至澳大利亚的节点反而容易连上</strong>。</p>\n<p>可以提前准备多个工具，这是目前我能找到的最可靠的方法。关注VPN厂商的邮件列表，提前询问客服，确定对方是否会近期推出“特殊版本”的软件更新。</p>\n<h1>各设备翻墙最佳姿势</h1>\n<h2>全设备翻墙</h2>\n<p>目前市场上还没有比<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>支持设备更多的翻墙软件，VyprVPN（变色龙版）不支持iOS，蓝灯不支持iOS，熊猫不支持路由器，其它一线的VPN也都有遗漏，只有ExpressVPN，基本从头到脚支持所有市场上你能找得到的设备类型，所以它应该是全设备通用翻墙的首选工具。</p>\n<h2>电脑翻墙</h2>\n<p>电脑上VPN，蓝灯，SSR都是可行的方案。对小白来说，VPN和蓝灯的客户端省去配置的麻烦，花钱省时间。如果懂技术，SSR也不错。</p>\n<h2>安卓翻墙</h2>\n<p>安卓手机上，VPN和蓝灯翻墙都不错。看个人习惯，SSR也可以用，只是好用的客户端安装配置可能要花点时间。友情提醒一下，<strong>尽量不要在第三方安卓市场上下载安装所谓“终身免费VPN”</strong>，警惕这类软件钓鱼，在你的手机窃密。</p>\n<h2>iOS翻墙</h2>\n<p>iPhone、iPad等iOS上翻墙，VyprVPN和蓝灯是用不了的，你的在几个一线VPN或者SSR方案里选，这些VPN中国苹果手机上都能用。如果选SSR，可以考虑买知名的ShadowRocket客户端。</p>\n<h2>路由器翻墙</h2>\n<p>我还没看到那款科学上网工具能支持所有制式的路由器的，我想未来也不会有。在你决定要用路由器做翻墙网关前，要看清楚你选择的翻墙软件支不支持你的路由器型号，我建议以<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>支持的路由器列表为参考（如果它不支持，其它工具也大概率不会支持），如果不支持，你得考虑购买兼容的路由器型号。</p>\n<h2>智能电视翻墙</h2>\n<p>不管是Apple TV，还是各种安卓电视（小米盒子、天猫盒子、FireTV），本质上它们仍然是安装了iOS或Android操作系统类手机设备，看前面的安卓和iOS翻墙。</p>\n<h2>游戏主机翻墙</h2>\n<p>能支持游戏主机（PlayStagion，Xbox，Nintendo Switch）的翻墙工具本来就很少，能支持多种此类设备的就更是凤毛麟角，目前对游戏设备支持最好的科学上网工具，是<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>。</p>\n<h1>蓝灯介绍</h1>\n<p><img src=\"https://static.cnodejs.org/FkPGWuKIqmRZWOADMT7glQ8meS19\" alt=\"蓝灯.jpg\"></p>\n<h2>蓝灯不是VPN</h2>\n<p>蓝灯不是VPN，基于SOCKS5协议的加密代理，技术上和ShadowSocks接近。如果网上有人告诉你有蓝灯VPN可以下载，基本都是钓鱼的下载链接，蓝灯就是一个代理翻墙工具，只不过客户端自动化了代理设置的很多细节。</p>\n<p>代理类科学上网工具的优缺点：建立连接的速度一般比传统VPN快，理论上SOCKS协议的传输开销比VPN小，速度比VPN快，缺点是没有VPN作为底层协议那么通用，而且隐私保护的强度没有用付费VPN翻墙那么强。</p>\n<h2>蓝灯优缺点</h2>\n<p>蓝灯相比传统VPN的优缺点：连接速度确实很快，ExpressVPN平均可能需要几十秒才能建立连接，但蓝灯基本是秒连，不过我用两者分别看Youtube并感觉不到速度差距。设备支持上，蓝灯提供Windows，MacOS，安卓客户端，下载安装方便，有中国可访问的<a href=\"https://github.com/getlantern/lantern\">github</a>页面，国内应该可以直接下载到蓝灯客户端，安装后可以使用免费版，用户可以在客户端里购买蓝灯专业版，支持支付宝付款，比较方便。</p>\n<p>蓝灯内置了两个比较有用的功能，一个是自动检测被墙网站并配置智能连接，只对这些网站应用科学上网，另一个是广告拦截，自动过滤掉各类广告和追踪请求，也很实用。</p>\n<p><strong>但是很可惜，蓝灯不支持iOS</strong> :((</p>\n<h2>专业版</h2>\n<p>蓝灯有免费版和专业版，免费版每月500M流量，蓝灯专业版的的价格也不贵。免费版很有用，可以拿来临时翻墙以此为跳板下载各类付费科学上网工具。蓝灯专业版是从客户端内购的，可以支付宝付款。</p>\n<p>不管是免费版还是专业版，<strong>蓝灯都不提供手动连接</strong>，连哪里是完全由客户端自动管理的，这对有的人来说是个优点，但对需要特定地区连接节点的人（比如需要特定IP的外服游戏玩家）来说，非常不好用。</p>\n<h2>破解版</h2>\n<p>提醒一下：网上如果流传所谓<strong>蓝灯破解版</strong>千万别下，小心挂马。蓝灯是需要客户端和服务器端协同才能正常翻墙的软件，下到一个所谓破解版是不可能可用的，一定是骗人的。把所谓破解版装到电脑上会对系统带来安全隐患。</p>\n<h2>优惠码</h2>\n<p>最后附上蓝灯优惠码：<strong>NQGP7F</strong>。想买的朋友可以用。再次提醒：<strong>蓝灯不支持iOS设备</strong>，有iOS设备的朋友，用VPN翻墙工具是最好的办法。</p>\n<h1>SSR科学上网</h1>\n<p><a href=\"https://www.wallmama.com/ssr\">SSR</a>，又称“小飞机”，或“影梭”，是<a href=\"https://shadowsocks.org/en/index.html\">ShadowSocks</a>的后续版本，目前仍保持着更新（原项目黄了）。</p>\n<p>这种方法也是完全可行的，国内很多人用，现在最常见的SSR，也有小众用户用V2Ray，WireGuard等技术，总的来说SSR够用。</p>\n<p>用得最多的VPS是<a href=\"https://indx.cc/vtr\">Vultr</a>和<a href=\"https://indx.cc/bwg\">搬瓦工</a>，网上不少人反应IP被封，但也有很多人自己搭建的SSR稳定用很久的，所以这里有运气成分。</p>\n<p>自己搭建SSR并不比买VPN便宜，即使便宜其实也很有限，主要还是VPS厂商经常送新注册用户试用金，所以感觉上一开始不用花钱，大家觉得便宜，最便宜的VPS如Vultr的2.5美金每月的，也和一些VPN的价格差不多，VPS普遍的低配机价格是5美金或以上的。</p>\n<p>要有IP被封的心里准备，好在现在的VPS换IP都不麻烦，大不了做个镜像重新开一台机会拿到新IP。不过并不是所有的换IP都免费，如果考虑换IP的成本，<strong>搭建SSR的成本未必比其它方法低</strong>。</p>\n<h1>翻墙须知</h1>\n<h2>墙并没有那么高</h2>\n<p>国内网名觉得墙很高，其实每年除了少数几个时段外，用VPN或SSR翻墙并不难，虽然也谈不上特别容易，毕竟购买VPN或者搭建SSR都要费时间费钱。很多人觉得科学上网难，大概就是几类原因。首先就是不想花钱，整天找免费的东西，免费VPN，免费SSR节点分享，免费的东西很多，也有一些确实能用的，但几乎所有免费服务最终都是很难或不可用的。绝大多数免费的VPN或者SSR节点，公网上随便一搜就搜得到，你能看到墙也能看到，多数都很短命。其次就是懂点技术的网民的那一点偏执，觉得自己架设的东西最好，不相信第三方更专业的付费服务。国内很多人用香港、日本等地的主机来搭SSR，有不少确实是稳定地用着，但也有不少IP被封，不得不折腾换IP、换主机的。所以它们觉得翻墙很难。</p>\n<p>其实翻墙只需要准备一两个工具就行了，像我自己就常备<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>和<a href=\"https://indx.cc/lantern\">蓝灯</a>，用了好几年了，除了少数敏感时期两个都挂掉以外，其余时间基本可以保证100%翻墙成功率，绝大多数时候我用ExpressVPN，虽然每天都会有几次断线重连，但极少碰到连不上的情况，最糟糕的情况也就是换个节点连一下，香港的如果连起来慢了，就换洛杉矶的，洛杉矶的慢了，就换日本、新加坡的等等。蓝灯用来作备份，因为价格便宜，但没有ExpressVPN强大，有了这两个软件，我从来没担心过无法科学上网的问题。剩下的，就是保持两个工具的更新，这是同时安装两个翻墙软件的好处，主要是为了当一个软件版本过期无法连接的时候，另一个还能连上让它更新。</p>\n<h2>为何翻墙？</h2>\n<p>翻墙是为了不影响学习与工作，不是去诋毁中国和中国人。</p>\n<p>你要明白世界的媒体是受西方控制的，舆论战里众多西方媒体是进攻的一方，而非西方阵营的国家只能选择防守，我们不说墙的存在对你我个人是好或不好，方便与不方便，如果说这个，当大概是不好也不方便，但也得明白防火墙存在在政治与国家安全上的‘合理性’。比如Facebook被封的原因：</p>\n<blockquote>\n<p>由于乌鲁木齐七·五骚乱部分新疆独立运动者使用Facebook为交流平台，引起中国大陆封锁Facebook至今。</p>\n</blockquote>\n<p>绝大多数西方媒体都带有浓烈的意识形态企图，它们绝对不是“公正中立”的，明白这一点的中国人会越来越多。<a href=\"https://user.guancha.cn/main/content?id=29826\">选择性报道，恶意扭曲的例子并不少</a>，甚至一度还有“中国共产党镇压狗”的奇葩新闻，西方媒体说谎作恶，无所不用其极。翻墙绝对不是为了去做西方媒体的喉舌，你只要被绕进去，就很难看到全部的事实了。翻墙是首先是为了不影响个人学习与工作，其次是为了更好地学习和工作，还当然有娱乐：）Googe，Youtube，Facebook，Twitter上都有大量有益的信息可以看。况且前面说了，对个人来说，墙的门槛实际上并没有你想的那么高，墙的存在并不能阻止你获得这些信息。</p>\n<p>不要假设“翻墙后”的必然选择是搞些猎奇反动的事情，翻墙后有很多有趣、有意义的东西可以看。有一些免费翻墙工具背后是美国国会支持的，典型代表是曾经流行的自由门，就有美国国会几百万美金的拨款，自由门绝对不是唯一一款，这种免费VPN会向用户不停推送反动信息，好在几年前被封了。</p>\n<h2>翻墙是否违法</h2>\n<p>如果翻墙违法，那中国政府就有几千万人要抓，经济上没有可行性。如果强制立法翻墙违法，中国政府也不会不知道其中的政治代价，除非它想让中国整个进入黑暗时代。所以基本上个人翻墙违不违法是个伪命题，日常翻个墙查个Gmail，看个Youtube没必要提心吊胆，不要被网络上所谓“翻墙罪”危言耸听蛊惑。</p>\n<p><strong>绝不要分发分享自建VPN，SSR机场，脚本等</strong></p>\n<p>国内有些小朋友看到搭建SSR这么容易，就去建机场，这是典型的作死，可以自行去搜机场主或者站长被请抓的新闻。个人VPN，SSR你自己用，请保持低调。不要到微信、微博这些地方去分发，除非你很想喝茶。分发分享自建VPN，SSR机场是犯法的。 看下面这些事件：</p>\n<p><strong>2019年3月，翻墙技术网站“逗比根据地”站长被起诉：</strong></p>\n<p>“逗比根据地”是一个提供翻墙技术的中文网站。2018年底，该网站创始人孙东洋（网名Toyo Sun）在国内被捕。在被关押5个多月后，孙东洋于2019年3月25日被以“提供侵入计算机系统工具罪”起诉。</p>\n<p><strong>2019年1月，重庆网民因使用VPN受到指控：</strong></p>\n<p>2019年1月，据网络流传的图片显示，重庆市荣昌区公安局对一名使用VPN的网民黄某的家属进行了传唤。</p>\n<p><strong>2019年1月，广东网民因使用VPN被罚款：</strong></p>\n<p>2019年1月，广东一位朱姓网民因为“擅自建立、使用非法定信道进行国际联网”被韶关市公安局警告并罚款1,000元人民币。文件显示：朱某从2018年8月到12月，在自己手机上多次使用翻墙软件蓝灯（Lantern Pro）。这是一次因个人使用VPN被罚的事件。</p>\n<h2>隐藏IP地址</h2>\n<p>连上VPN后，所有流量都走VPN软件提供的线路，相当于在本机与VPN远程服务器之间建立起一条秘密通道，入口是本机端口，出口是服务器某个端口，对被访问的网站等服务来说，直接访问者是远程服务器，从而达到隐藏本机IP地址的目的。</p>\n<p>隐藏IP地址即是保护隐私的需要，在需要访问有IP限制的服务时（如Netflix只允许部分国家的IP访问）也非常有用。</p>\n<h2><a href=\"https://en.wikipedia.org/wiki/DNS_leak\">DNS泄漏保护</a></h2>\n<p>上面说了VPN会在本机和远程服务器间开辟隧道，让流量同行，通常指的流量是数据流量，比如下载网页，DNS泄露保护，是将本机对网站域名的访问请求（转化为IP）也走VPN通道的保护机制，它最大限度地保护用户隐私，否则网络中间商就可以侦测到你的机器都访问了哪些域名，有了DNS泄露保护，网络中间商就无法嗅探到你的网站访问记录了。</p>\n<h2>混淆协议</h2>\n<p>单纯的VPN协议如OpenVPN虽然也有加密算法，但在GFW防火墙面前也不堪一击。所以好的VPN软件都会单独开发混淆协议。混淆的作用就是把VPN流量尽可能搞得不像VPN加密流量，骗过墙的侦测算法，更有效地帮助用户翻墙。</p>\n<p>ExpressVPN，VyprVPN等软件都开发了商用混淆协议，这是这类软件比普通VPN更稳定的原因。</p>\n<h2>什么是智能连接（Split Tunneling）</h2>\n<p>当你连上VPN软件后，默认所有流量都走VPN连接，这会导致访问中国国内网站（如知乎、百度、微博、优酷等）变慢。Split Tunneling允许你指定那些应用程序不走VPN线路，如在<a href=\"https://indx.cc/expcnd\">ExpressVPN</a>内，你可以配置Firefox浏览器不走VPN，Chrome浏览器走VPN，这样访问国内站点时用Firefox，访问国外站点时用Chrome，国内外网站访问速度都能达到最优。</p>\n</div>","title":"翻墙与科学上网，中国VPN推荐","last_reply_at":"2020-12-24T04:48:49.799Z","good":false,"top":false,"reply_count":10,"visit_count":18372,"create_at":"2018-05-31T10:03:07.553Z","author":{"loginname":"wallmama","avatar_url":"https://avatars3.githubusercontent.com/u/39631585?v=4&s=120"}},{"id":"5fe331a798427ee7ed6aa0c9","author_id":"5cab188c7edd13064e05363f","tab":"ask","content":"<div class=\"markdown-text\"><p>我直接pm2 reload不香吗，，，是我手法有问题吗，，github action远程ssh 执行docker这一堆脚本</p>\n</div>","title":"docker 运行nodejs，如何做到自动化部署，难道只能停止容器->删除容器->删除旧镜像->打包新镜像->容器运行新镜像？","last_reply_at":"2020-12-24T02:05:48.805Z","good":false,"top":false,"reply_count":1,"visit_count":82,"create_at":"2020-12-23T12:01:43.407Z","author":{"loginname":"ganshiqingyuan","avatar_url":"https://avatars0.githubusercontent.com/u/33950951?v=4&s=120"}},{"id":"5fe1a41c98427e93df6a9cb9","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>目前在网络上搜索到node.js用的文件上传框架为multer,地址为:<a href=\"https://github.com/expressjs/multer\">https://github.com/expressjs/multer</a>.\n大家还有没有更好的推荐啊?如果有的话麻烦推荐一下,十分感谢</p>\n</div>","title":"麻烦大家推荐一个文件上传框架","last_reply_at":"2020-12-24T01:04:48.396Z","good":false,"top":false,"reply_count":5,"visit_count":196,"create_at":"2020-12-22T07:45:32.184Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5fe3450d98427e30f76aa0eb","author_id":"57cd6dbc8624502e4751354e","tab":"share","content":"<div class=\"markdown-text\"><p>Vue 3.0 发布已经好一阵子了，eslint-plugin-vue 更新的规则甚多，故一直没来得及跟进。\n现终于把所有的新配置都加上啦，也翻译了一波。\n欢迎升级到 v3.9.0 使用 <a href=\"https://github.com/AlloyTeam/eslint-config-alloy\">https://github.com/AlloyTeam/eslint-config-alloy</a></p>\n<p>PS：Vue 杂七杂八的规则是真的多。</p>\n<p>如果有需要自定义规则的也可以参考我这个翻译：</p>\n<ul>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-multiple-objects-in-class\">vue/no-multiple-objects-in-class</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-multiple-slot-args\">vue/no-multiple-slot-args</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-multiple-template-root\">vue/no-multiple-template-root</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-mutating-props\">vue/no-mutating-props</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-potential-component-option-typo\">vue/no-potential-component-option-typo</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-ref-as-operand\">vue/no-ref-as-operand</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-restricted-component-options\">vue/no-restricted-component-options</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-restricted-custom-event\">vue/no-restricted-custom-event</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-restricted-props\">vue/no-restricted-props</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-restricted-static-attribute\">vue/no-restricted-static-attribute</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-restricted-v-bind\">vue/no-restricted-v-bind</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-setup-props-destructure\">vue/no-setup-props-destructure</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-sparse-arrays\">vue/no-sparse-arrays</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-template-target-blank\">vue/no-template-target-blank</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-unregistered-components\">vue/no-unregistered-components</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-unused-properties\">vue/no-unused-properties</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-useless-concat\">vue/no-useless-concat</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-useless-mustaches\">vue/no-useless-mustaches</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-useless-v-bind\">vue/no-useless-v-bind</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-v-for-template-key-on-child\">vue/no-v-for-template-key-on-child</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-v-for-template-key\">vue/no-v-for-template-key</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-v-model-argument\">vue/no-v-model-argument</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/no-watch-after-await\">vue/no-watch-after-await</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/one-component-per-file\">vue/one-component-per-file</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/prefer-template\">vue/prefer-template</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/require-explicit-emits\">vue/require-explicit-emits</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/require-slots-as-functions\">vue/require-slots-as-functions</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/require-toggle-inside-transition\">vue/require-toggle-inside-transition</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/return-in-emits-validator\">vue/return-in-emits-validator</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/v-for-delimiter-style\">vue/v-for-delimiter-style</a></li>\n<li><a href=\"https://alloyteam.github.io/eslint-config-alloy/?language=zh-CN&amp;rule=vue#vue/valid-v-is\">vue/valid-v-is</a></li>\n</ul>\n</div>","title":"eslint-config-alloy 支持 Vue 3.0 啦","last_reply_at":"2020-12-23T13:24:29.580Z","good":false,"top":false,"reply_count":0,"visit_count":51,"create_at":"2020-12-23T13:24:29.580Z","author":{"loginname":"xcatliu","avatar_url":"https://avatars0.githubusercontent.com/u/5453359?v=4&s=120"}},{"id":"5fe1368b98427e82fe6a9b02","author_id":"51b1e5ebf78196a85c0f0dee","tab":"share","content":"<div class=\"markdown-text\"><p>对于大型互联网应用来说，面对持续增长的海量业务数据，分布式数据库架构几乎是标准配置。而如何让业务开发人员在面向分布式数据库开发时如同在同一个库中，让数据分片对应用开发人员透明，将副作用降到最低，是众多优秀程序员持续追求的目标。</p>\n<p><img src=\"//forum-assets.wuyuan.io/4/d4f4f4f4-43b7-4f80-bb3a-5243bf372dce16081992164770\" alt></p>\n<p>本文将通过一个简单实例，介绍如何使用 ShardingSphere 分片中间件，实现 Enhancer 应用对后台分布式数据库的操作。希望对您使用 Enhancer 应用管理大型分布式业务数据有所启发。</p>\n<h1>目标效果</h1>\n<p><img src=\"//forum-assets.wuyuan.io/4/336e4c0c-8fcc-42e4-9576-8be2e6c11d3216081901649150\" alt></p>\n<h1>实现步骤</h1>\n<h3>1. 准备 4 台 mysql 服务器并创建相关的实验数据库和表</h3>\n<ul>\n<li>1.1. 创建四个数据库分别命名为 user_db_0, user_db_1, user_db_2, user_db_3</li>\n<li>1.2. 在每个库中创建用户表</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>CREATE TABLE &#96;t_user&#96; (\n  &#96;id&#96; int(11) NOT NULL DEFAULT &#x27;0&#x27;,\n  &#96;name&#96; varchar(40) DEFAULT NULL,\n  &#96;gender&#96; char(1) DEFAULT NULL,\n  &#96;phone&#96; varchar(20) DEFAULT NULL,\n  &#96;address&#96; varchar(255) DEFAULT NULL,\n  &#96;created&#96; datetime DEFAULT NULL,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre><h3>2. 下载并安装 ShardingSphere</h3>\n<ul>\n<li>2.1.下载。实际上需要使用的是 ShardingSphere 的跨语言中间件产品 ShardingProxy : <a href=\"https://www.apache.org/dyn/closer.cgi/shardingsphere/5.0.0-alpha/apache-shardingsphere-5.0.0-alpha-shardingsphere-proxy-bin.tar.gz\">下载地址</a></li>\n</ul>\n<p><img src=\"//forum-assets.wuyuan.io/2/87f22edc-2146-43bb-89a8-9077fbe4ca7816081875476971\" alt></p>\n<ul>\n<li>2.2. 解压 tar 包，得到 apache-shardingsphere-xxx-shardingsphere-proxy-bin 目录。</li>\n<li>2.3. 下载 mysql 连接器 jar 包: <a href=\"https://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar\">mysql-connector-java-5.1.47.jar</a>，并将该 jar 包放入 apache-shardingsphere-xxx-shardingsphere-proxy-bin/lib 目录中。</li>\n</ul>\n<h3>3. 配置代理服务器和数据库分片规则</h3>\n<ul>\n<li>3.1 配置代理服务器 apache-shardingsphere-xxx-shardingsphere-proxy-bin/conf/server.yaml 文件，\n此文件描述了将来用作 Enhancer 工作台配置数据库连接的相关信息。注意配置文件中 <code>[xxxx]</code> （含中括号）为需要自行修改部分:</li>\n</ul>\n<pre class=\"prettyprint language-yaml\"><code>authentication:\n  users:\n    root:\n      password: [xxx]\n    [db_account_xxx]:\n      password: [xxx]\n      authorizedSchemas: user_db\n\nprops:\n  max-connections-size-per-query: 1\n  acceptor-size: 16  # The default value is available processors count * 2.\n  executor-size: 16  # Infinite by default.\n  proxy-frontend-flush-threshold: 128  # The default value is 128.\n    # LOCAL: Proxy will run with LOCAL transaction.\n    # XA: Proxy will run with XA transaction.\n    # BASE: Proxy will run with B.A.S.E transaction.\n  proxy-transaction-type: LOCAL\n  proxy-opentracing-enabled: false\n  proxy-hint-enabled: false\n  query-with-cipher-column: true\n  sql-show: false\n  check-table-metadata-enabled: false\n</code></pre><ul>\n<li>3.2 配置分片规则 apache-shardingsphere-xxx-shardingsphere-proxy-bin/conf/config-sharding.yaml 文件，此文件配置了分片数据库源信息和\nt_user 表在分布式数据库中的分片规则信息。注意配置文件中 <code>[xxxx]</code> （含中括号）为需要自行修改部分:</li>\n</ul>\n<pre class=\"prettyprint language-yaml\"><code>schemaName: user_db\n\ndataSourceCommon:\n connectionTimeoutMilliseconds: 30000\n idleTimeoutMilliseconds: 60000\n maxLifetimeMilliseconds: 1800000\n maxPoolSize: 50\n minPoolSize: 1\n maintenanceIntervalMilliseconds: 30000\n\ndataSources:\n  ds_0:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址0]:3306&#x2F;user_db_0?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_1:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址1]:3306&#x2F;user_db_1?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_2:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址2]:3306&#x2F;user_db_2?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\n  ds_3:\n    url: jdbc:mysql:&#x2F;&#x2F;[数据库IP地址3]:3306&#x2F;user_db_3?serverTimezone=UTC&amp;useSSL=false&amp;characterEncoding=utf8\n    username: [xxx]\n    password: [xxx]\nrules:\n- !SHARDING\n  tables:\n    t_user:\n      actualDataNodes: ds_${0..3}.t_user # 配置表的实际数据节点数 0 ... n。\n      keyGenerateStrategy:\n        column: id\n        keyGeneratorName: snowflake\n  bindingTables:\n    - t_user\n  defaultDatabaseStrategy:\n    standard:\n      shardingColumn: id\n      shardingAlgorithmName: database_inline\n  defaultTableStrategy:\n    none:\n  \n  shardingAlgorithms:\n    database_inline:\n        type: INLINE\n        props:\n          algorithm-expression: ds_${id % 4}  # 使用简单的用 t_user 表的 id 字段对数据库节点数 n 求余规则来分片。\n          allow-range-query-with-inline-sharding: true\n  keyGenerators:\n    snowflake:\n      type: SNOWFLAKE\n      props:\n          worker-id: 123\n</code></pre><ul>\n<li>3.3 在 apache-shardingsphere-xxx-shardingsphere-proxy-bin 目录执行 ./bin/start.bat 或者 ./bin/start.sh 启动服务。</li>\n</ul>\n<h3>4. Enhancer 工作台配置连接 ShardingProxy，后续开发如常</h3>\n<ul>\n<li>\n<p>4.1. 在工作台-全局配置-数据库-连接中配置 3.1 所配置的数据库服务连接[用户 db_account_xxx]和[密码 password]，地址为 apache-shardingsphere-xxx-shardingsphere-proxy-bin 所在的机器地址，若在本机则填写为 127.0.0.1，端口号为 <code>3307</code>, 库名为 user_db。\n<img src=\"//forum-assets.wuyuan.io/2/87f22edc-2146-43bb-89a8-9077fbe4ca7816081875478612\" alt></p>\n</li>\n<li>\n<p>4.2. 在工作台-页面管理中创建一个页面，添加一个窗口组件 enhancer-jqgrid, 配置绑定 SQL：</p>\n</li>\n</ul>\n<pre class=\"prettyprint language-sql\"><code>SELECT * FROM t_user\n</code></pre><h2>至此，保存后可以运行起来查看效果，后续相关开发如常。</h2>\n<h3>结语</h3>\n<p>本例仅仅是实现了对单一表的分片增、删、改、查操作。在分布式数据库实战业务开发中，对于一些复杂场景，尤其是在金融级数据强完整性、强一致性、强可用性的要求下，分片中间件并不能做到完全对应用开发层透明，比如多个大表跨数据库 join, 分布式事务等等。此时一般需要通过应用层合理设计，来补偿或者规避这些问题（比如支付宝不允许你跨年查账，也不会提供一个界面同时呈现总账和明细账，需要用户分多次多层点开逐步呈现）。对于已经采用 IOE 结构实现的大规模金融级应用来说，在不改动应用层的情况下就实现去 IOE，还有很长的路要走。而对于一般电商、社交级互联网应用使用 Enhancer + ShardingSphere 来实现对分布式数据库的管理，会是一个不错的选择。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://shardingsphere.apache.org/document/current/en/user-manual/shardingsphere-proxy/configuration/data-source/\">ShardingProxy 配置手册</a></li>\n<li><a href=\"https://shardingsphere.apache.org/document/current/en/features/sharding/\">数据库分片概念原理</a></li>\n<li><a href=\"https://wuyuan.io\">无远开发平台</a></li>\n</ul>\n</div>","title":"Enhancer + ShardingSphere 实现分布式数据库应用开发","last_reply_at":"2020-12-23T12:13:14.527Z","good":false,"top":false,"reply_count":4,"visit_count":110,"create_at":"2020-12-21T23:58:03.025Z","author":{"loginname":"jquery","avatar_url":"https://avatars2.githubusercontent.com/u/3049683?v=4&s=120"}},{"id":"5fe2c5e998427ece0a6a9fbc","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><p>开源不易，感谢你的支持，<a href=\"https://github.com/concentjs/concent\">❤ star concent^_^</a>\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33479f07d8ab4b75b6724c7d7eabe9c8~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<h2>序言</h2>\n<p><code>nextjs</code>是一个非常流行的 React 服务端渲染应用框架，它很轻量，简单易上手，社区活跃，所以当我们使用<code>react</code>写一个需要<code>ssr</code>(server side render)的应用的话，基本都会首选<code>nextjs</code>，<code>concent</code>是一个新生代的<code>react</code>状态管理方案，它内置依赖收集系统，同时兼具有0入侵、可预测、渐进式、高性能的特点，并提供了<code>lifecyle</code>、<code>composition api</code>等灵活的api且写法超级简单，让你轻松驾驭超大规模的react应用。</p>\n<h2>Hello next</h2>\n<p>这里我们将使用<code>create-next-app</code>命令来安装一个基础的next示例应用</p>\n<pre class=\"prettyprint language-sh\"><code>npx create-next-app hello-next\n</code></pre><p>执行完毕后，可以看到一个如下的目录结构</p>\n<pre class=\"prettyprint\"><code>|____public\n|____pages\n| |____ _app.js   &#x2F;&#x2F; next应用默认的根组件\n| |____index.js   &#x2F;&#x2F; 默认首页\n| |____api        &#x2F;&#x2F; api路由文件\n| | |____hello.js \n</code></pre><p>之后我们在项目根目录执行<code>npm run dev</code>将看到一个由<code>next</code>驱动的<code>ssr</code>默认首页\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f739617e7fff4cb1a0bc955b51a48ffd~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<h2>Hello concent</h2>\n<p>这里我们将使用<code>create-react-app</code>命令来安装一个基础的concent示例应用</p>\n<pre class=\"prettyprint language-sh\"><code>npx create-react-app hello-concent --template concent-ts\n</code></pre><p>执行完毕后，可以看到一个如下的目录结构</p>\n<pre class=\"prettyprint\"><code>|____index.tsx\n|____App.tsx\n|____types\t\t\t&#x2F;&#x2F; store的类型定义处\n|____features   \t\t&#x2F;&#x2F; 功能组件列表\n| |____counter  \t\t&#x2F;&#x2F; counter功能\n| | |____Counter.tsx\t\t&#x2F;&#x2F; counter组件\n| | |____model\t\t\t&#x2F;&#x2F; counter模型(包含state,reducer,computed)\n|____models\t\t\t&#x2F;&#x2F; 其它全局通用的模型定义\n|____configs\n</code></pre><p>进入项目目录执行<code>npm i</code>，然后执行<code>npm start</code>即可看到一个默认的计数器页面\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39d54b2f27444598a9ed54f54b494e3c~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<blockquote>\n<p>你也可以点击<a href=\"https://codesandbox.io/s/cra-template-concent-ts-2x347?file=/src/App.tsx\">这里</a>在线了解和编辑它。</p>\n</blockquote>\n<p>当然了在已有的项目里集成<code>concent</code>里也超级简单，因为它无需顶层提供<code>Provider</code>，只需要提前配置好模型即可。</p>\n<pre class=\"prettyprint language-js\"><code>import { run } from &#x27;concent&#x27;;\n\nrun({ &#x2F;&#x2F; 定义一个counter模型\n  counter: {\n    state: { num: 1, bigNum: 10 },\n    reducer: {\n      add(payload, moduleState) {\n        return { num: moduleState + 1 };\n      },\n      async asyncAddBig() {\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n        return { bigNum: moduleState + 10 };\n      }\n    },\n    computed: {\n      doubleNum: ({ num }) =&gt; num * 2, &#x2F;&#x2F; 仅当num发生变化才触发此函数\n    }\n  }\n})\n</code></pre><p>之后就可以全局即插即用啦，类组件和函数组件都可以用同样的方式去读取数据或调用方法，敲重点啦，<strong>如果ui处是有条件语句控制是否要消费状态或衍生数据的话，推荐延迟解构的写法，这样可以让concent在每一轮渲染完毕后收集到视图对数据的最小粒度依赖</strong></p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; ###### 函数组件\nfunction Demo(){\n  &#x2F;&#x2F; 如 state 和 moduleComputed 是按需读取的，推荐延迟解构的写法\n  const { state: { num, numBig }, moduleComputed: { doubleNum }, mr } = useConcent(&#x27;counter&#x27;); \n  &#x2F;&#x2F; ... ui 逻辑，绑数据、绑方法\n}\n\n&#x2F;&#x2F; ###### 类组件\nconst DemoCls = register(&#x27;counter&#x27;)(\n  class DemoCls extends React.Component{\n   render(){\n      const { state: { num, numBig }, moduleComputed: { doubleNum }, mr } = this.ctx; \n      &#x2F;&#x2F; ... ui 逻辑，绑数据、绑方法\n    }\n  }\n)\n</code></pre><h2>在next里引入concent</h2>\n<p>next的基础示例目录里有个<code>_app.js</code>文件，它是next应用的根组件</p>\n<pre class=\"prettyprint language-js\"><code>import &#x27;..&#x2F;styles&#x2F;globals.css&#x27;\n\nfunction MyApp({ Component, pageProps }) {\n  return &lt;Component {...pageProps} &#x2F;&gt;\n}\n\nexport default MyApp\n</code></pre><p>因使用<code>concent</code>之前必需提前配置好模型，所以我们只需提前创建一个<code>runConcent.js</code>文件</p>\n<pre class=\"prettyprint language-js\"><code>import { run } from &#x27;concent&#x27;\nimport * as models from &#x27;.&#x2F;models&#x27;;\n\nrun(models);\n</code></pre><p>然后在<code>_app.js</code>文件引入即可，这样根组件下的所有子组件都能够正确获取到store的数据和调动store的方法了。</p>\n<pre class=\"prettyprint language-diff\"><code>import &#x27;..&#x2F;styles&#x2F;globals.css&#x27;\n+ import &#x27;.&#x2F;runConcent&#x27;\n\nfunction MyApp({ Component, pageProps }) {\n  return &lt;Component {...pageProps} &#x2F;&gt;\n}\n\nexport default MyApp\n</code></pre><p>接着我们在next的pages目录下创建一个<code>counter.js</code>文件，代表这是一个页面组件，这样浏览器端可以用<code>/counter</code>路由来访问到这个组件的渲染视图了。</p>\n<pre class=\"prettyprint language-js\"><code>import React from &#x27;react&#x27;\nimport { useConcent } from &#x27;concent&#x27;\nimport router from &#x27;next&#x2F;router&#x27;\n\n&#x2F;&#x2F; use next&#x2F;router to do browser side router jump\nfunction toHomePage(){\n  router.push(&#x27;&#x2F;&#x27;);\n}\n\nexport default function Counter() {\n  const { state, mr, moduleComputed } = useConcent(&#x27;home&#x27;)\n\n  return (\n    &lt;div&gt;\n      this is counter page\n      &lt;h1&gt;num: {state.num}&lt;&#x2F;h1&gt;\n      &lt;h1&gt;doubleNum: {moduleComputed.doubleNum}&lt;&#x2F;h1&gt;\n      &lt;button onClick={mr.add}&gt;add&lt;&#x2F;button&gt;\n      &lt;button onClick={toHomePage}&gt;to home page&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><p>大功告成，一个接入了<code>concent</code>的<code>next</code>应用就这样产生了，是不是特别简单呢？^_^</p>\n<h2>支持预渲染</h2>\n<p><code>next</code>提供两种级别的预渲染接口，即<code>getServerSideProps</code>和<code>getStaticProps</code>，两种的区别是执行时机不同，<code>getServerSideProps</code>是每次请求页面都会执行，而<code>getStaticProps</code>是构建时执行，我们先处理<code>getServerSideProps</code>这种情况吧，看看如何结合<code>concent</code>做预渲染支持。</p>\n<p>首先我们不考虑<code>concent</code>的存在，在<code>next</code>里做预渲染支持，只需要在你的页面组件里暴露一个<code>getServerSideProps</code>接口即可。</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 此函数在每次请求改页面时被调用\nexport async function getServerSideProps() {\n  &#x2F;&#x2F; 调用外部 API 获取博文列表\n  const res = await fetch(&#x27;https:&#x2F;&#x2F;...&#x2F;posts&#x27;)\n  const posts = await res.json()\n\n  &#x2F;&#x2F; 通过返回 { props: posts } 对象，PostPage 组件在渲染时将接收到 &#96;posts&#96; 参数\n  return {\n    props: { posts },\n  }\n}\n\nfunction PostPage({ posts }) { &#x2F;&#x2F; 这里接收到了 posts 参数\n  &#x2F;&#x2F; Render posts...\n}\n\nexport default PostPage\n</code></pre><p>之所以<code>Blog</code>能够接到<code>posts</code>，除了暴露这个<code>getServerSideProps</code>这个接口之外，我们再观察一下<code>_app.js</code>这个根组件文件内容，可以发现关键点所在！</p>\n<pre class=\"prettyprint language-js\"><code>function MyApp({ Component, pageProps }) {\n  return &lt;Component {...pageProps} &#x2F;&gt;\n}\nexport default MyApp\n</code></pre><p>参数列表里的<code>pageProps</code>即是<code>getServerSideProps</code>返回结果里<code>props</code>指向的对象，然后<code>next</code>将其透传到目标页面组件上，所以我们才能够在<code>PostPage</code>参数列表里解构出<code>posts</code>。</p>\n<p>所以我们的切入点就可以从这里入手了，我们把getStaticProps的返回结果做一下格式约束，形如<code>{module:string, state: object}</code>这样的结构，然后在<code>_app.js</code>文件里记录到store即可</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; 此函数在每次请求时被调用\nexport async function getServerSideProps() {\n  &#x2F;&#x2F; 调用外部 API 获取博文列表\n  await delay();\n  const posts = [\n    { id: 1, name: &#x27;post1 -----&#x27; },\n    { id: 2, name: &#x27;post2 --- welcome to use concent&#x27; },\n  ];\n  &#x2F;&#x2F; 这个返回对象会透传给根组件的pageProps，在此返回状态所属的模块和状态实体对象\n  &#x2F;&#x2F; 在那里将状态记录到store\n  return {\n    props: {\n      module: &#x27;test&#x27;,\n      state: { posts },\n    }\n  };\n}\n</code></pre><p>此时的根组件文件改变如下</p>\n<pre class=\"prettyprint language-diff\"><code>import &#x27;..&#x2F;styles&#x2F;globals.css&#x27;;\n+ import &#x27;.&#x2F;runConcent&#x27;;\n+ import { setState } from &#x27;concent&#x27;;\n\nfunction MyApp({ Component, pageProps }) {\n  &#x2F;&#x2F; 这里记录 getServerSideProps 的返回状态到store的对应模块\n+  if (pageProps.module) {\n+    setState(pageProps.module, pageProps.state);\n+  }\n  return &lt;Component {...pageProps} &#x2F;&gt;\n}\nexport default MyApp;\n</code></pre><p>然后我们实现的页面组件<code>post-page</code>代码如下</p>\n<pre class=\"prettyprint language-js\"><code>const PostList = React.memo(function () {\n  const { state } = useConcent(&#x27;test&#x27;);\n  return (\n    &lt;div&gt;\n      {state.posts.map(item =&gt; &lt;h3 key={item.id}&gt;{item.name}&lt;&#x2F;h3&gt;)}\n    &lt;&#x2F;div&gt;\n  );\n});\n\nconst PostLength = React.memo(function () {\n  const { state } = useConcent(&#x27;test&#x27;);\n  return &lt;h1&gt;{state.posts.length}&lt;&#x2F;h1&gt;;\n});\n\nexport default function PostPage() {\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;this is post page&lt;&#x2F;h1&gt;\n      &lt;PostList &#x2F;&gt;\n      &lt;PostLength &#x2F;&gt;\n      &lt;button onClick={toHomePage}&gt;to home page&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n}\n</code></pre><p>接着我们打开浏览器访问<code>/post-page</code>页面吧，点击查看源码将会看到这是一个服务器端预渲染的页面\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccdd2abc0bab47ff9cf157ae569765b1~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<p>同理，我们也可将<code>getServerSideProps</code>替换为<code>getStaticProps</code>，上面的整个流程将依然正常工作，欢迎各位看官clone示例代码来亲自体验一下。</p>\n<pre class=\"prettyprint language-sh\"><code>git clone https:&#x2F;&#x2F;github.com&#x2F;concentjs&#x2F;ssr-demo-1\n</code></pre><h2>附录</h2>\n<h3>doc</h3>\n<ul>\n<li><a href=\"https://www.nextjs.cn/\">next-js doc</a></li>\n<li><a href=\"https://concentjs.github.io/concent-doc/\">concent doc</a></li>\n</ul>\n<h3>CloudBase CMS</h3>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d22f440f82d548cc98dd941bf6348e27~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<p>欢迎小哥哥们来撩<a href=\"https://github.com/TencentCloudBase/cloudbase-extension-cms\">CloudBase CMS</a> ，打造一站式云端内容管理系统，它是云开发推出的，基于 Node.js 的 Headless 内容管理平台，提供了丰富的内容管理功能，安装简单，易于二次开发，并与云开发的生态体系紧密结合，助力开发者提升开发效率。</p>\n<blockquote>\n<p><code>concent</code>已为其管理后台提供强力支持，新版的管理界面更加美观和体贴了。</p>\n</blockquote>\n<h3>FFCreator</h3>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd7c067bc604123b8d71709be56be8b~tplv-k3u1fbpfcp-watermark.image\" alt></p>\n<p>也欢迎小哥哥们来撩<a href=\"https://github.com/tnfe/FFCreator\">FFCreator</a>，它是一个基于node.js的轻量、灵活的短视频加工库。您只需要添加几张图片或视频片段再加一段背景音乐，就可以快速生成一个很酷的视频短片。</p>\n<blockquote>\n<p><code>FFCreator</code>是一种轻量又简单的解决方案，只需要很少的依赖和较低的机器配置就可以快速开始工作。并且它模拟实现了animate.css90%的动画效果，您可以轻松地把 web 页面端的动画效果转为视频，真的很给力。</p>\n</blockquote>\n</div>","title":"助力ssr，使用concent为nextjs应用加点料","last_reply_at":"2020-12-23T04:22:01.953Z","good":false,"top":false,"reply_count":0,"visit_count":91,"create_at":"2020-12-23T04:22:01.953Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5f322ce36c9ee864cf0e4751","author_id":"5f322c8a2799ce64a0aabac9","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>我使用 Vue 和 React 已经很长一段时间了，两个框架上实践代码量都在 10 万行以上。不得不说两者都是很 nice 的，帮助开发者减少很多工作量，这类框架是现代化前端开发必备的。然而 Vue 和 React 两者之间的选择并不像选择苹果或香蕉一样简单，两者在工程实践上的差距让我们逐渐放弃了 Vue。本文以不一样的角度对两者进行深度对比。</p>\n</blockquote>\n<p><a href=\"https://taskhub.work/article/79319258450055168\">为什么我们放弃了 Vue？Vue 和 React 深度对比</a></p>\n</div>","title":"为什么我们放弃了 Vue？Vue 和 React 深度对比","last_reply_at":"2020-12-23T03:44:04.450Z","good":false,"top":false,"reply_count":12,"visit_count":4689,"create_at":"2020-08-11T05:30:11.408Z","author":{"loginname":"Q-Qplus1s","avatar_url":"https://avatars1.githubusercontent.com/u/50064165?v=4&s=120"}},{"id":"5fe00b420f99cb5d385e3a74","author_id":"5fdc5fc50f99cb58285e36e8","tab":"ask","content":"<div class=\"markdown-text\"><p>比如引入一个JS框架文件，然后不需要写任何html，调用jsapi就能制作出应用\n看了大多数框架都是无一例外要写大量html</p>\n</div>","title":"目前有没有哪个前端UI框架只用JS就能生成页面的","last_reply_at":"2020-12-23T03:05:16.996Z","good":false,"top":false,"reply_count":2,"visit_count":243,"create_at":"2020-12-21T02:41:06.592Z","author":{"loginname":"takayama-lily","avatar_url":"https://avatars3.githubusercontent.com/u/12014361?v=4&s=120"}},{"id":"5fe1a9ba98427e75ef6a9cfb","author_id":"5bc6779d37a6965f5905229a","tab":"share","content":"<div class=\"markdown-text\"><p>人流失的很多，挂站後没法进来，都去别的地方了。cnodejs.org不是挂站了吗？一直进不好来，今天查个东西，逛进来，发现网站又活了</p>\n</div>","title":"人流失的很多，挂站後没法进来，都去别的地方了。cnodejs.org不是挂站了吗？一直进不好来，今天查个东西，逛进来，发现网站又活了","last_reply_at":"2020-12-23T03:04:19.632Z","good":false,"top":false,"reply_count":3,"visit_count":241,"create_at":"2020-12-22T08:09:30.546Z","author":{"loginname":"Solomonqoo","avatar_url":"https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"}},{"id":"5fe1fb9e98427e4f9c6a9ed4","author_id":"540d094b541e9b2f6a466d2d","tab":"share","content":"<div class=\"markdown-text\"><h2>这是什么?</h2>\n<p>这是一个高性能的基于<code>puppeteer</code>的<code>SSR</code>方案, 他使用Headless Chrome从网页中生成html,然后以http的方法返回html内容</p>\n<h2>解决了什么问题</h2>\n<p>很多公司和开发者使用JavaScript框架(包括AngularJS，BackboneJS，ReactJS, VueJS)开发应用程序和网站。但很多搜索引擎，社交媒体，爬虫不支持抓取JavaScript的网页，也就无法做网站SEO。</p>\n<p>&lt;b&gt;通过UserAgent判断,如果是来自于爬虫, 则通过nginx(tomcat, Apache)等反向代理到本服务,则可以把渲染好的html网页内容传递给搜索引擎, 从而间接实现SEO, 从而间接实现 SEO, 这样,既可以保持纯粹的前端开始思路, 还能节省 SSR 造成的服务器负担&lt;/b&gt;</p>\n<p>也可以使用在爬虫采集, 生成网页截图,生成网页PDF场景</p>\n<h2>github</h2>\n<p><a href=\"https://github.com/zuoyanart/sparender\">https://github.com/zuoyanart/sparender</a></p>\n<h2>使用</h2>\n<pre class=\"prettyprint language-js\"><code>git clone  \ncd sparender\nnpm i\nnpm start\n</code></pre><h2>免费接入</h2>\n<p><a href=\"http://www.zuoyanit.com/jieru\">免费接入SSR渲染</a></p>\n<p>请求地址: <a href=\"http://api.zuoyanit.com/render\">http://api.zuoyanit.com/render</a></p>\n<p>请求方式: GET</p>\n<p>请求示例: <a href=\"http://api.zuoyanit.com/render/http://www.zuoyanit.com\">http://api.zuoyanit.com/render/http://www.zuoyanit.com</a></p>\n<p>反向代理配置请参阅: <a href=\"http://www.zuoyanit.com/wendang-4-20list\">文档</a></p>\n<ul>\n<li>\n<p>为了防止滥用,使用前请联系作者,设置域名白名单</p>\n</li>\n<li>\n<p>免费提供200个页面(以redis中存的记录条数为准)</p>\n</li>\n</ul>\n<h2>查看效果</h2>\n<pre class=\"prettyprint language-js\"><code>http:&#x2F;&#x2F;127.0.0.1:3001&#x2F;render?url=http:&#x2F;&#x2F;www.example.com\n</code></pre><h3>功能</h3>\n<ul>\n<li>puppeteer连接池</li>\n<li>render并发限制</li>\n<li>log4j 日志</li>\n<li>已集成任务调度</li>\n<li>生产，开发环境配置</li>\n<li>redis缓存</li>\n<li>自动来路, 如果来自移动端则自动设置请求UA和viewpoint(使用iphoneX的环境参数)</li>\n</ul>\n</div>","title":"分享一个基于puppeteer的高性能spa(vue, react等)SEO解决方案","last_reply_at":"2020-12-22T13:58:54.529Z","good":false,"top":false,"reply_count":0,"visit_count":95,"create_at":"2020-12-22T13:58:54.529Z","author":{"loginname":"spnt","avatar_url":"https://avatars3.githubusercontent.com/u/3346390?v=4&s=120"}},{"id":"545249abd0c2f0fe2f533ad6","author_id":"544475344ca29a4d4c08c331","tab":"ask","content":"<div class=\"markdown-text\"><p>rt</p>\n</div>","title":"请教大神们，都怎么实现‘科学上网’撒","last_reply_at":"2020-12-22T13:35:53.240Z","good":false,"top":false,"reply_count":20,"visit_count":8901,"create_at":"2014-10-30T14:22:35.923Z","author":{"loginname":"iamnotblank","avatar_url":"https://avatars1.githubusercontent.com/u/6949176?v=4&s=120"}},{"id":"5fe04e3b98427e1d416a98df","author_id":"59eeb8e11bbf067d5c3fa7c6","tab":"share","content":"<div class=\"markdown-text\"><p>截至2020年12月21日冬至，花了近5年时间作出最小可用NodeJS开源全栈框架，这就是CabloyJS V4.0.0</p>\n<p>5年，90个模块，30万行代码，5400次提交(Commits)，开启NodeJS全栈开发的全新体验</p>\n<h2>CabloyJS V4.0.0主要完成了以下特性</h2>\n<ul>\n<li>采用lerna将cabloy所有核心模块集中在一个源码仓库管理</li>\n<li>基于原生JS的Bean容器和AOP架构\n<ul>\n<li>几乎所有事物都是Bean</li>\n<li>Bean支持AOP</li>\n<li>AOP也是一种Bean</li>\n</ul>\n</li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/flow-introduce.html\">通用的NodeJS工作流引擎</a></li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/atom-stage.html\">原子三生三世（数据的生命周期管理）</a>：草稿-&gt;归档-&gt;历史</li>\n<li>基于NodeJS工作流引擎的草稿审核业务流</li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/adaptive-layout.html\">PC端与移动端自适应</a>：页面组件只需要开发一次。不是采用<code>media query</code>，也不是采用<code>iframe</code>，而是真正的把手机操控体验带入PC端。只要用一下，就会有一种<code>相逢恨晚</code>的感觉</li>\n<li>统计值自动更新与推送架构。比如，我有多少待办一目了然。这是一个通用的架构，可以简便的匹配到任何场景</li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/wechat-introduce.html\">接口对接</a>：微信公众号、企业微信、钉钉企业应用</li>\n<li>基于Redis的原生分布式架构\n<ul>\n<li><a href=\"https://cabloy.com/zh-cn/articles/queue.html\">Queue</a></li>\n</ul>\n<ul>\n<li><a href=\"https://cabloy.com/zh-cn/articles/schedule.html\">Schedule</a></li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/broadcast.html\">Broadcast</a></li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/cache.html\">Cache</a></li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/startup.html\">Startup</a></li>\n</ul>\n</li>\n<li>基于socketio的消息推送架构</li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/5c90f4fd15174772adb34dfbf6d1adfb.html\">具有部件间数据绑定机制的“仪表板”架构</a></li>\n<li><a href=\"https://cabloy.com/zh-cn/articles/28f14f839af5457b9243c9e9210d5324.html\">高度定制化的PC端布局</a>：header、sidebar、statusbar</li>\n</ul>\n<h2>相关链接</h2>\n<ul>\n<li><a href=\"https://cabloy.com/\">官网: https://cabloy.com/</a></li>\n<li><a href=\"https://github.com/zhennann/cabloy\">GitHub: https://github.com/zhennann/cabloy</a></li>\n</ul>\n</div>","title":"CabloyJS v4.0.0支持工作流引擎及更多 🎉","last_reply_at":"2020-12-22T09:47:13.718Z","good":false,"top":false,"reply_count":1,"visit_count":115,"create_at":"2020-12-21T07:26:51.977Z","author":{"loginname":"zhennann","avatar_url":"https://avatars1.githubusercontent.com/u/24246985?v=4&s=120"}},{"id":"5698d752adf526da2aeb237f","author_id":"530ed7b25adfcd9c0f0713b6","tab":"share","content":"<div class=\"markdown-text\"><blockquote>\n<p>原文：<a href=\"http://www.jianshu.com/p/f0f65f15d295\">如果你用GitHub，可以这样提高效率</a></p>\n</blockquote>\n<p>一年时间我们从几个人的开发团队发展到十几人的团队，最初的我们只有两个后端加两个前端，而且其中三个还是实习生。\n但今时不同往日，现在我们有前端、后端、测试、运维、设计、产品、交互，成功集齐了七个兵种，可以召唤神龙，赐我们一个敏捷的开发团队。\n作为一个敏捷性的开发团队，我们要保持快速的迭代速度的同时保证高质量的代码，这是一个艰巨的过程。</p>\n<h3>版本管理 — Git~Hub</h3>\n<blockquote>\n<p>「开始的开始，我们还是孩子」(出自《北京路的日子》)</p>\n</blockquote>\n<p>开始的开始，我们还是用着SVN，代码存储在公司的服务器中，只有一个分支，提交代码无需审核，无需单元测试。因为我们只有几个人…</p>\n<p>作为一个有逼格的团队，后来我们用上了Git，并且把代码迁移到Coding中去，然后引入了名为「git flow」的工作流，关于这个工作流可以参考我们老大的文章：<a href=\"http://www.jianshu.com/p/104fa8b15d1e\">「企业级开发：Gitflow Workflow工作流」</a></p>\n<p>Coding真的是一款很不错的产品，可称为业届良心。</p>\n<p>为什么当初没有直接用GitHub，因为私有仓库贵啊…</p>\n<p>但，作为一个有逼格的团队，我们是不会满足于此的。Coding自身的服务很不错了，但是相对于GitHub的一些专业的第三方服务，缺少了那么一些竞争力。我们当时想接入持续集成的服务，但是无奈找不到支持Coding的第三方服务，代码Review也没有一个更让我们舒心的体验，我承认我们要求比较高。再加上Coding的几次down机，其中一次是我们准备发布新版本的那一个下午…</p>\n<p>终于有一天，我们老大两眼发光的跟我们说：我们要买GitHub的服务了，申请到资金了。</p>\n<p>于是乎，我们浩浩荡荡的迁移代码库。</p>\n<p>迁移到Github之后，我们开始接入各方工具，提高我们的工作效率（钱可不能白花啊）。</p>\n<h3>武装GitHub — ZenHub</h3>\n<blockquote>\n<p><a href=\"https://www.zenhub.io/\">ZenHub</a><br>\nProject management inside GitHub<br>\nTransform your GitHub issues</p>\n</blockquote>\n<p>正如Zenhub所说，这是一款项目管理工具，嵌入式集成到GitHub中。作为插件，它的UI完全迎合了GitHub，以至于你难以分别出哪些功能是GitHub的，哪些功能是Zenhub的。</p>\n<p>如果你用了ZenHub，它会提供给你：</p>\n<ol>\n<li><strong>一套任务面板</strong>，给不同的任务提供不同的泳道，直观的展示每个任务的进度。于是乎我抛弃了Teambition。</li>\n<li><strong>一套个人的Todo List</strong>，如果有一个issue或者一个PR需要你来处理，但你现在没有空，你可以把它添加到Todo List中，于是乎我又抛弃了Wunderlist。</li>\n<li><strong>一套项目图标与统计</strong>，结合着Github自带的项目图表，这个提供更多维度的数据，但是个人感觉意义不太大。</li>\n<li><strong>再加一些小彩蛋</strong>，由于它是作为插件形式嵌入到Github中的，所以会在很多地方提供一些这样那样的按钮，等着你去发现了。</li>\n</ol>\n<h3>持续集成 — TravisCI</h3>\n<blockquote>\n<p><a href=\"https://travis-ci.org/\">TravisCI</a><br>\nTest and Deploy with Confidence<br>\nEasily sync your GitHub projects with Travis CI and you’ll be testing your code in minutes!</p>\n</blockquote>\n<p>不知道你有没有好奇Github上的一些明星项目的这样的标签：</p>\n<p><a href=\"https://travis-ci.org/strongloop/express\"><img src=\"https://travis-ci.org/strongloop/express.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p>这个是Express的构建状态的标签，格式是svg，它会根据Express的构建状态改变。如果Express的某一次提交是没有通过TravisCI构建的，他会变成 build failing。（有心人可以点击这个标签进去看看。）</p>\n<p>我们加入TravisCI主要目的是用于自动化的单元测试，每一次Commit与PR，TravisCI都会从Github仓库中拉取代码，然后执行我们写好的单元测试，通过与否会通过状态展示出来。<br>\n合并的人如果看到build failing，就不会合并了，这在一定程度上保证与提高了代码的质量。</p>\n<p>TravisCI除了可以用来自动化单元测试，还可以自动化部署，可以设定，通过测试之后，就自动部署上线。</p>\n<p>TravisCI对于公开仓库是免费的，但对于私有仓库是要收费的，而且价格也不便宜。<br>\n如果你觉得贵，这里还有一个可以代替的：<strong><a href=\"https://circleci.com/\">CircleCI</a></strong><br>\nTravisCI可以做的，它都可以做得到，而且会提供一个免费的私有仓库。</p>\n<h3>代码Review — Reviewable</h3>\n<blockquote>\n<p><a href=\"https://reviewable.io/\">Reviewable</a>\nGitHub code reviews done right</p>\n</blockquote>\n<p>如果你觉得Github自带的Review还不够满足的话，可以尝试一下这款产品。\n当你提交一个PR之后，在你的PR中，会在你的评论框中嵌入这样的按钮</p>\n<p><img src=\"//static.cnodejs.org/FrDLVgDD6alCXnHAfk4XNHJCCnS_\" alt></p>\n<p>点击进入Reviewable的页面对应的PR进行review。</p>\n<p>并且一个PR没有完成Review之前，是会一直被警告，让你警惕进行合并。</p>\n<h3>代码覆盖率 — Coveralls</h3>\n<blockquote>\n<p><a href=\"http://coveralls.io/\">Coveralls</a><br>\nWe help you deliver code confidently by showing which parts of your code aren’t covered by your test suite. Free for open source repos. Pro accounts for private repos. Instant sign up through GitHub and Bitbucket.</p>\n</blockquote>\n<p>在明星项目Express的Github项目主页中，你可以看到这样的标签：</p>\n<p><a href=\"https://coveralls.io/github/strongloop/express?branch=master\"><img src=\"https://coveralls.io/repos/strongloop/express/badge.svg?branch=master&amp;service=github\" alt=\"Coverage Status\"></a></p>\n<p>结合着TravisCI的自动化单元测试，加上这个测试覆盖率，提高你对项目的信心。</p>\n<h3>快速进行沟通 — Slack</h3>\n<blockquote>\n<p><a href=\"https://slack.com/\">Slack</a><br>\nA messaging app for teams who see through the Earth</p>\n</blockquote>\n<p>相信大部分团队都是使用微信进行沟通的，<br>\n再一次，最为一个有逼格的团队，我们使用了Slack进行团队上的沟通，在Slack上，你可以创建频道(Channel)，不同Channel不同的人进行着不同的话题沟通。我们有设计的Channel、产品的Channel、开发的Channel。我最欣赏的是，Slack可以接入很多第三方服务，Github是其中一个。</p>\n<p>接入Github之后，项目的每一个Commit、PR之类的动态信息，会被推送到聊天室中。</p>\n<p>助你时刻掌控项目动态。</p>\n<p><img src=\"//static.cnodejs.org/FjrMtthZ9pX08AWOKbIPlogDKBcK\" alt></p>\n<p>Slack接入Githu只是其中的一个小功能而已，更强大的在于Slack本身，利器如何用，待君慢慢体会。</p>\n<p><strong>但</strong>，Slack有一个硬伤：不会科学上网，用不了呀。</p>\n<h3>最后</h3>\n<p>再一次，作为一个有逼格的团队，我们依然不会满足现状。</p>\n</div>","title":"如果你用GitHub，可以这样提高效率","last_reply_at":"2020-12-22T09:29:17.788Z","good":true,"top":false,"reply_count":10,"visit_count":8445,"create_at":"2016-01-15T11:26:10.689Z","author":{"loginname":"JerryC8080","avatar_url":"https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"}},{"id":"5f8575a672af8c02d3f8e691","author_id":"5875bd3d06fa6e2a4e4f730b","tab":"ask","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"域名被封了还有人么","last_reply_at":"2020-12-22T08:20:41.895Z","good":false,"top":false,"reply_count":12,"visit_count":1106,"create_at":"2020-10-13T09:38:46.068Z","author":{"loginname":"zy445566","avatar_url":"https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"}},{"id":"5f6b1edcd22a6b1d622ca0dc","author_id":"5594b1fa47e6bdc30297eb0c","tab":"ask","content":"<div class=\"markdown-text\"><p>如题公司比较急招人，我也很希望能够推进这事，所以想问问大家知不知道其他什么 nodejs 的社区可以招人呀？小众或者不能发招聘帖也没关系，因为我自己也是主攻 Javascript 开发的所以也想借此机会开拓下视野。</p>\n<p>谢谢 😃</p>\n</div>","title":"请问国内还有哪些 nodejs 社区？","last_reply_at":"2020-12-22T08:17:44.531Z","good":false,"top":false,"reply_count":23,"visit_count":1786,"create_at":"2020-09-23T10:09:32.568Z","author":{"loginname":"xieaolin","avatar_url":"https://avatars0.githubusercontent.com/u/858724?v=4&s=120"}},{"id":"53b93bab1b009b31532ef934","author_id":"50f7a0a9df9e9fcc5889a1b0","content":"<div class=\"markdown-text\"><p>要安全的, 要用gmail.\n封这么厉害…</p>\n</div>","title":"有靠谱的VPN推荐吗?","last_reply_at":"2020-12-22T07:56:13.918Z","good":false,"top":false,"reply_count":71,"visit_count":181936,"create_at":"2014-07-06T12:06:03.451Z","author":{"loginname":"ronincn","avatar_url":"//gravatar.com/avatar/0582e15ee13a3fef9d78dac6f0c71575?size=48"}},{"id":"5b13b00f8a4f51e140d944b9","author_id":"5b13af8c29e6e510415b273c","tab":"share","content":"<div class=\"markdown-text\"><p>本文是关于WordPress主机推荐的</p>\n<p>网站管理平台、域名domain和主机空间hosting是构成一个独立博客/网站的三个重要组成部分</p>\n<p>域名的话，非常推荐在<a href=\"https://www.namesilo.com/?rid=adf2827hj\">namesilo</a>注册(拿去用，1美元注册优惠码：webcom)，简单好用不骚扰</p>\n<p>这个页面主要简单介绍和推荐几个好用的优质国外WordPress虚拟主机，不要用免费的，所谓的&quot;免费&quot;都不过是幌子而已，也不要用国内的主机，还得备案等，不多解释。</p>\n<p>WordPress是目前最主流的网站搭建平台，根据维基百科的介绍，全球前1000万的网站中，有大概30%的网站是基于WordPress搭建的，所以你打算搭建个人的独立博客或网站的话，WordPress肯定会是一个非常不错的平台。</p>\n<p>以下虚拟主机都支持WordPress网站的一键快速安装；都可以通过PayPal或visa等国际信用卡付款，基本上也都支持支付宝；最重要的是都可以在购买之后的规定期限内发起退款，有问题可以随时联系在线客服。</p>\n<p>. <a href=\"https://www.bluehost.com/track/ykq\">bluehost</a>，公司总部在美国犹他州，2003年成立，WordPress org官方推荐第一位的主机，有超过200多万的优质网站在这里搭建，免费提供SSL(https)，30天内可退款。<em>另，bluehost客服确认所谓的bluehost中国其实跟bluehost官方是两个不同的系统，虽然它们共用一个主域名，故不再推荐在bluehost中国购买，需要的直接在<a href=\"https://www.bluehost.com/track/ykq\">bluehost.com</a>官网购买，当然你自己拿主意</em></p>\n<p>. <a href=\"https://mbsy.co/rdmwW\">dreamhost</a>，也是WordPress(WP) org官方推荐的主机提供商，1997年在美国的加利福尼亚州注册成立，长期与WP ORG合作，WP一键安装，也提供免费SSL，其Shared hosting主机产品97天内可以退款，其多数主机产品都提供免费域名，<em>不过还是推荐在专门的namesilo那里购买域名</em></p>\n<p>. <a href=\"https://partners.hostgator.com/KBOoA\">hostgator</a>，2003年成立，公司位于美国德克萨斯州，其标志是一条鳄鱼，45天内可以退款，提供免费SSL。有专门的<a href=\"https://partners.hostgator.com/9Vnb0\">中文网页</a>，可以支付宝。</p>\n<p>. <a href=\"https://my.hawkhost.com/aff.php?aff=12414\">hawkhost</a>，其标志是一个老鹰，2004年在加拿大成立，可以支付宝，30天内可以发起退款，它提供的主机主要分布在加拿大、美国、欧洲荷兰，亚洲的中国香港和新加坡。</p>\n<p>. <a href=\"https://www.siteground.com/index.htm?afcode=d374ff711fd59832e23687367eb84f3c\">site ground</a>，<strong>非常好用，客户评价非常好，特别推荐</strong>，siteground公司在美国田纳西州，2003年成立，它也是WordPress org的官方推荐主机，针对WP特别优化，备份最近30天，shared wordpress hosting30天/一个月内可以退款，cloud hosting 14天/两个星期内可退款，速度、稳定性什么的都非常好，在线客服支持非常的专业高效，放在最后的原因是它的付款对于中国用户比较麻烦点，只接受visa/mastercard万事达卡等国际信用卡，PayPal的话需要在购买的时候联系客服，不支持支付宝。</p>\n<p>/ 简单说一下主机空间地理位置的选择，中文博客/网站的话，建议选择亚洲的机房，比如中国香港、新加坡或日本和韩国的，当然也只是建议。\nwp网站的theme主题的选择：一般来说，默认的那几个主题就可以的，当然你也可以搜索选择自己喜欢的免费主题风格，或者也可以考虑使用付费主题</p>\n<p>以上哪个主机最好？ 尺有所短、寸有所长，不能绝对的说哪个最好用，都不错，根据你个人的需要、偏好和预算等选一个合适的就行了。</p>\n<p><em>“wordpress” “网站” “博客” “国外” “美国” “香港” “主机” “域名” “主题” “教程” “建站” “推荐” “website” “blog” “hosting” “com domain”</em></p>\n</div>","title":"几个非常好用的国外(wordpress)虚拟主机推荐","last_reply_at":"2020-12-22T06:58:59.636Z","good":false,"top":false,"reply_count":2,"visit_count":3633,"create_at":"2018-06-03T09:08:31.991Z","author":{"loginname":"jbxccgc","avatar_url":"https://avatars0.githubusercontent.com/u/39874984?v=4&s=120"}},{"id":"5fdf47ea0f99cb4d6b5e39b6","author_id":"51b44498f78196a85c3f28b7","tab":"ask","content":"<div class=\"markdown-text\"><p>现在在控制器中有段逻辑是写pdf文件，耗时约1秒多，加上此逻辑就无响应数据。\n伪代码:\nclass MyController {\nasync logic(){\nawait createPdf() //这个耗时操作，注销掉就可正常返回数据.\nctx.attachment(*.pdf);\nctx.body={“success”};\n}\n}\n@大神们，这种是否设计错误。请赐教</p>\n</div>","title":"Egg.js 控制器中有耗时操作,就无响应数据","last_reply_at":"2020-12-22T02:50:18.167Z","good":false,"top":false,"reply_count":18,"visit_count":292,"create_at":"2020-12-20T12:47:38.533Z","author":{"loginname":"nobody","avatar_url":"https://avatars1.githubusercontent.com/u/12067939?v=4&s=120"}},{"id":"5fdd66c00f99cbe4ac5e3873","author_id":"5ab852d6320bb09d69e231f1","tab":"ask","content":"<div class=\"markdown-text\"><p>麻烦问一下大家,一些不经常改变并且有用的参数，应该放在什么地方存储？比如数据库的配置参数以及一些token参数等\n1：直接写到了json文件里（很方便但是不安全）\n2：写到数据库里,然后用Redis做缓存（目前使用这种）\n3：定义全局变量，全局变量缓存Redis里的内容\n想用第三种方法，因为第二种方法会造成频繁的对Redis进行访问，不知道第三种方法有没有什么问题！或者大家都是怎么做的啊？</p>\n</div>","title":"配置参数应该存放在哪里？json redis ?","last_reply_at":"2020-12-21T07:26:56.756Z","good":false,"top":false,"reply_count":6,"visit_count":265,"create_at":"2020-12-19T02:34:40.454Z","author":{"loginname":"iori2882","avatar_url":"https://avatars3.githubusercontent.com/u/1480587?v=4&s=120"}},{"id":"5fdf51250f99cb099c5e39c9","author_id":"59eeb8e11bbf067d5c3fa7c6","tab":"share","content":"<div class=\"markdown-text\"><h2>前言</h2>\n<p>众所周知，NodeJS作为后端开发语言和运行环境，样样都好，就差一个<code>NodeJS工作流引擎</code>。CabloyJS 4.0重点开发了<code>NodeJS工作流引擎</code>，并作为内置的基础核心模块，近一步拓展了NodeJS在后端的应用场景，为深入研发各类商业业务逻辑，提供了基础支撑</p>\n<h2>NodeJS工作流引擎的特点</h2>\n<ol>\n<li>更简便的配置：采用<code>JSON</code>进行流程定义的配置，告别XML配置文件的冗杂</li>\n<li>流程定义：支持历史版本、支持启用/禁用</li>\n<li>更清晰的架构：采用三个核心模块用分层的机制实现工作流引擎的架构，让工作流不再神秘，源码也不再叠床架屋</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>模块名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a-flow</td>\n<td>流程定义、流程实例</td>\n</tr>\n<tr>\n<td>a-flownode</td>\n<td>流程节点（活动节点）</td>\n</tr>\n<tr>\n<td>a-flowtask</td>\n<td>流程任务</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>支持<code>业务流程</code>和<code>审批流程</code></li>\n<li>与<code>Atom三生三世</code>结合，内置了一套基于Atom的<code>审批工作流</code>。参见：<a href=\"https://cabloy.com/zh-cn/articles/atom-stage.html\">原子阶段（三生三世）</a></li>\n<li>与<code>表单验证</code>结合，支持分别配置不同流程节点的<code>读取字段权限</code>和<code>修改字段权限</code>。参见：<a href=\"https://cabloy.com/zh-cn/articles/form-validation.html\">表单验证</a></li>\n<li>可通过<code>AOP</code>机制定制工作流逻辑</li>\n<li>可通过<code>Listener</code>机制定制工作流逻辑</li>\n<li>开放式的架构，支持更多<code>流程节点</code>的定制开发</li>\n<li>包含大量<code>测试驱动</code>代码，可快速上手使用工作流</li>\n</ol>\n<h2>工作流演示</h2>\n<ol>\n<li>新建一个草稿：<code>采购订单</code></li>\n<li>选择要使用的<code>流程定义</code>，然后提交，草稿进入相应的<code>审批流程</code></li>\n<li>签收任务、并处理任务</li>\n<li>流程结束，草稿转为<code>归档</code></li>\n</ol>\n<p><img src=\"https://admin.cabloy.com/api/a/file/file/download/a2e337ef9450431cbd130f8da48eb392.gif\" alt=\"flow-zhcn\"></p>\n<h2>一个最简工作流定义</h2>\n<p><code>src/module/test-flow/backend/src/config/static/flowDef/set00_simple.js</code></p>\n<pre class=\"prettyprint language- javascript\"><code>  {\n    listener: null,\n    process: {\n      nodes: [\n        {\n          id: &#x27;startEvent_1&#x27;,\n          name: &#x27;Start&#x27;,\n          type: &#x27;startEventNone&#x27;,\n        },\n        {\n          id: &#x27;endEvent_1&#x27;,\n          name: &#x27;End&#x27;,\n          type: &#x27;endEventNone&#x27;,\n        },\n      ],\n      edges: [\n        {\n          id: &#x27;edge_1&#x27;,\n          source: &#x27;startEvent_1&#x27;,\n          target: &#x27;endEvent_1&#x27;,\n        },\n      ],\n    },\n  }\n</code></pre><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>listener</td>\n<td>监听器，可监听flow/node/task各类事件</td>\n</tr>\n<tr>\n<td>process.nodes</td>\n<td>流程节点</td>\n</tr>\n<tr>\n<td>process.nodes.type</td>\n<td>流程节点类型</td>\n</tr>\n<tr>\n<td>process.edges</td>\n<td>流程转移线</td>\n</tr>\n<tr>\n<td>process.edges.source</td>\n<td>来源</td>\n</tr>\n<tr>\n<td>process.edges.target</td>\n<td>去向</td>\n</tr>\n</tbody>\n</table>\n<h2>一个审批流程定义</h2>\n<p><code>src/module/test-flow/backend/src/config/static/flowDef/set01_atomUserTask.js</code></p>\n<pre class=\"prettyprint language- javascript\"><code>  {\n    listener: null,\n    process: {\n      nodes: [\n        {\n          id: &#x27;startEvent_1&#x27;,\n          name: &#x27;Drafting&#x27;,\n          type: &#x27;startEventAtom&#x27;,\n          options: {\n            atom: {\n              module: moduleInfo.relativeName,\n              atomClassName: &#x27;purchaseOrder&#x27;,\n            },\n            conditionExpression: &#x27;atom._flowDefKey===\\&#x27;set01_atomUserTask\\&#x27;&#x27;,\n          },\n        },\n        {\n          id: &#x27;activity_1&#x27;,\n          name: &#x27;Review&#x27;,\n          type: &#x27;activityUserTask&#x27;,\n          options: {\n            assignees: {\n              &#x2F;&#x2F; users: &#x27;1,2&#x27;,\n              &#x2F;&#x2F; roles: &#x27;1,2&#x27;,\n              vars: &#x27;flowUser&#x27;,\n            },\n            confirmation: false,\n            bidding: false,\n            completionCondition: {\n              &#x2F;&#x2F; passed: 1,\n              &#x2F;&#x2F; rejected: &#x27;100%&#x27;,\n            },\n            &#x2F;&#x2F; rejectedNode:null,\n            &#x2F;&#x2F; allowRejectTask: true,\n            &#x2F;&#x2F; allowCancelFlow: false,\n            schema: {\n              write: [\n                &#x27;atomName&#x27;,\n                {\n                  name: &#x27;description&#x27;,\n                  property: {\n                    type: &#x27;string&#x27;,\n                    ebType: &#x27;text&#x27;,\n                    ebTitle: &#x27;Description&#x27;,\n                  },\n                },\n              ],\n            },\n          },\n        },\n        {\n          id: &#x27;endEvent_1&#x27;,\n          name: &#x27;End&#x27;,\n          type: &#x27;endEventNone&#x27;,\n        },\n      ],\n      edges: [\n        {\n          id: &#x27;edge_1&#x27;,\n          source: &#x27;startEvent_1&#x27;,\n          target: &#x27;activity_1&#x27;,\n        },\n        {\n          id: &#x27;edge_2&#x27;,\n          source: &#x27;activity_1&#x27;,\n          target: &#x27;endEvent_1&#x27;,\n        },\n      ],\n    },\n  }\n</code></pre><ul>\n<li>process.nodes.type</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>startEventAtom</td>\n<td><code>开始事件节点（起草）</code>：通过options.atom和options.conditionExpression与指定的Atom类型绑定。当指定的Atom提交时自动启动相匹配的工作流定义</td>\n</tr>\n<tr>\n<td>activityUserTask</td>\n<td><code>用户任务节点</code>：可指定参与人、是否竞签、完成条件、读字段权限、写字段权限，等等</td>\n</tr>\n<tr>\n<td>endEventNone</td>\n<td><code>结束事件节点</code></td>\n</tr>\n</tbody>\n</table>\n<h2>相关链接</h2>\n<ul>\n<li><a href=\"https://cabloy.com/\">官网: https://cabloy.com/</a></li>\n<li><a href=\"https://github.com/zhennann/cabloy\">GitHub: https://github.com/zhennann/cabloy</a></li>\n</ul>\n</div>","title":"CabloyJS也有工作流引擎了，是你想要的吗？","last_reply_at":"2020-12-20T13:27:01.857Z","good":false,"top":false,"reply_count":0,"visit_count":132,"create_at":"2020-12-20T13:27:01.857Z","author":{"loginname":"zhennann","avatar_url":"https://avatars1.githubusercontent.com/u/24246985?v=4&s=120"}},{"id":"5fdefd980f99cbcd025e397c","author_id":"50b5bc5d637ffa4155091236","tab":"share","content":"<div class=\"markdown-text\"><p>从咸鱼app到 各咎网站的客户端，flutter的感觉就是凑合能用，谁有flutter写的比较精致的app 看看</p>\n</div>","title":"flutter写的app是不是勉强凑合能用","last_reply_at":"2020-12-20T07:30:32.503Z","good":false,"top":false,"reply_count":0,"visit_count":309,"create_at":"2020-12-20T07:30:32.503Z","author":{"loginname":"yakczh","avatar_url":"https://avatars3.githubusercontent.com/u/6591466?v=4&s=120"}},{"id":"575c0f3a2ad3c06f1aa3d5ed","author_id":"56cd160ac045c3743304beec","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li>别用国内付费VPN服务，<strong>Green就是教训</strong>。</li>\n<li>别想着“免费”，能用的付费vpn得花钱，不便宜，<strong>便宜的根本没法用</strong>，几十块一年的等于智商税。</li>\n<li><strong>没有100%稳定高速的服务</strong>，特殊时段，即使付费vpn也不能总是“高速稳定”，别指望一年365天一天24小时随时1080p油管。</li>\n<li>一线国外付费VPN能保证的是“<strong>较好</strong>”的连通率和速度，不完美，但至少能用google，gmail和可接受的油管速度，这仍是目前最好的方案。</li>\n</ul>\n<p><strong>国内还能用支付宝买到</strong>的国外付费vpn推荐：</p>\n<h2><a href=\"https://indx.cc/exp\">ExpressVPN</a></h2>\n<p>全球148+服务器所在地 / 无限流量 / 多协议，包括openVPN / 一键连接 / 同时3台设备 / 256-bit AES加密 / 支付宝支付 / 支持路由器连接 / 完全IP隐藏 / 零日志 / 全终端覆盖 / 30天无条件退款 / Split tunneling技术 + 浏览器插件，同时访问内外网 / <strong>速度相对最快</strong></p>\n<h2><a href=\"https://indx.cc/pandavpn\">熊猫VPN</a></h2>\n<p><code>缺点：运营时间还比较短，只支持同时3个连接，且不支持路由器和Linux，缺乏自动重连等职能功能。</code></p>\n<p>VPN的后起之秀，正在促销，<strong>买一年送一年</strong>，服务器亲测可用，而且很快。产品运营时间还不长，处于推广阶段，价格优惠幅度很大。</p>\n<p>支持Windows，Mac，iOS，Android客户端。连接VPN只需要一个开关即可。界面极其简洁，同时3台设备，这是一个让人惊喜的发现，支持智能分流。</p>\n<p><strong>虽然熊猫VPN远没有ExpressVPN强大，如客户端支持远没有ExpressVPN丰富，同时也只支持3个连接，官方也不披露日志政策</strong>，但对不少人也应该日常够用。从客户端来看，熊猫VPN背后可能不是VPN翻墙技术，而是用了类似SSR的某种加密代理，这无法确定，但是能用最重要。</p>\n<h2><a href=\"https://indx.cc/vyr\">VyprVPN</a></h2>\n<p>70+自有服务器所在地，200,000+IP地址 / 无限流量 / 多协议，独家混淆协议 / 一键连接 / 同时5台设备 / 支持P2P / 变色龙加密，<strong>连接相对最稳定</strong> / 支付宝支付 / 支持路由器连接 / NAT安全机制 / DNS加密 / 全终端覆盖 / 2年款最大优惠 / 30天无条件退款 / 按程序控制网络技术，同时访问内外网</p>\n</div>","title":"稳定的付费vpn推荐","last_reply_at":"2020-12-19T09:40:37.381Z","good":false,"top":false,"reply_count":11,"visit_count":10623,"create_at":"2016-06-11T13:16:42.992Z","author":{"loginname":"flamingtop","avatar_url":"https://avatars3.githubusercontent.com/u/132677?v=4&s=120"}},{"id":"5fddb8d70f99cb8e265e38ca","author_id":"5b0eaaf38a4f51e140d9437d","tab":"share","content":"<div class=\"markdown-text\"><p>上一节讲解了迭代器的使用，如果对迭代器还不够了解的可以在回顾下<a href=\"https://mp.weixin.qq.com/s/UI3r3u50vYkrUTVe2DS86A\">《从理解到实现轻松掌握 ES6 中的迭代器》</a>，目前在 JavaScript 中还没有被默认设定 <code>[Symbol.asyncIterator]</code> 属性的内建对象，但是在 Node.js 中已有部分核心模块（Stream、Events）和一些第三方 NPM 模块（mongodb）已支持 Symbol.asyncIterator 属性。本文也是探索异步迭代器在 Node.js 中的都有哪些使用场景，欢迎留言探讨。</p>\n<h2>目录</h2>\n<ul>\n<li>在 Events 中使用 asyncIterator\n<ul>\n<li>events.on() 示例 1</li>\n<li>events.on() 示例 2</li>\n<li>events.on() 开启一个 Node.js 服务器</li>\n<li>解析 Node.js 源码对 events.on 异步迭代器的实现</li>\n</ul>\n</li>\n<li>在 Stream 中使用 asyncIterator\n<ul>\n<li>异步迭代器 与 Readable</li>\n<li>从 Node.js 源码看 readable 是如何实现的 asyncIterator</li>\n<li>异步迭代器与 Writeable</li>\n</ul>\n</li>\n<li>在 MongoDB 中使用 asyncIterator\n<ul>\n<li>MongoDB 中的 cursor</li>\n<li>MongoDB 异步迭代器实现源码分析</li>\n<li>使用 for await…of 遍历可迭代对象 cursor</li>\n<li>传送 cursor 到可写流</li>\n</ul>\n</li>\n</ul>\n<h2>在 Events 中使用 asyncIterator</h2>\n<p>Node.js v12.16.0 中新增了 events.on(emitter, eventName) 方法，返回一个迭代 eventName 事件的异步迭代器。</p>\n<h3>events.on() 示例 1</h3>\n<p>如下例所示， <code>for await...of</code> 循环只会输出 Hello 当触发 error 事件时会被 try catch 所捕获。</p>\n<pre class=\"prettyprint language-javascript\"><code>const { on, EventEmitter } = require(&#x27;events&#x27;);\n\n(async () =&gt; {\n  const ee = new EventEmitter();\n  const ite = on(ee, &#x27;foo&#x27;);\n\n  process.nextTick(() =&gt; {\n    ee.emit(&#x27;foo&#x27;, &#x27;Hello&#x27;);\n    ee.emit(&#x27;error&#x27;, new Error(&#x27;unknown mistake.&#x27;))\n    ee.emit(&#x27;foo&#x27;, &#x27;Node.js&#x27;);\n  });\n\n  try {\n    for await (const event of ite) {\n      console.log(event); &#x2F;&#x2F; prints [&#x27;Hello&#x27;]\n    }\n  } catch (err) {\n    console.log(err.message); &#x2F;&#x2F; unknown mistake.\n  }\n})();\n</code></pre><p>上述示例，如果 EventEmitter 对象实例 ee 触发了 error 事件，错误信息会被抛出并且退出循环，该实例注册的所有事件侦听器也会一并移除。</p>\n<h3>events.on() 示例 2</h3>\n<p><strong>for await…of 内部块的执行是同步的，每次只能处理一个事件，即使你接下来还有会立即执行的事件，也是如此。如果是需要并发执行的则不建议使用，这个原因会在下面解析 events.on() 源码时给出答案</strong>。</p>\n<p>如下所示，虽然事件是按顺序同时触发了两次，但是在内部块模拟了 2s 的延迟，下一次事件的处理也会得到延迟。</p>\n<pre class=\"prettyprint language-javascript\"><code>const ite = on(ee, &#x27;foo&#x27;);\n\nprocess.nextTick(() =&gt; {\n  ee.emit(&#x27;foo&#x27;, &#x27;Hello&#x27;);\n  ee.emit(&#x27;foo&#x27;, &#x27;Node.js&#x27;);\n  &#x2F;&#x2F; ite.return(); &#x2F;&#x2F; 调用后可以结束 for await...of 的遍历\n  &#x2F;&#x2F; ite.throw() &#x2F;&#x2F; 迭代器对象抛出一个错误\n});\n\ntry {\n  for await (const event of ite) {\n    console.log(event); &#x2F;&#x2F; prints [&#x27;Hello&#x27;] [&#x27;Node.js&#x27;]\n    await sleep(2000);\n  }\n} catch (err) {\n  console.log(err.message);\n}\n\n&#x2F;&#x2F; Unreachable here\nconsole.log(&#x27;这里将不会被执行&#x27;);\n</code></pre><p>上例中最后一句代码是不会执行的，此时的迭代器会一直处于遍历中，虽然上面两个事件 emit 都触发了，但是迭代器并没有终止，什么时候终止呢？也就是当内部出现一些错误或我们手动调用可迭代对象的 return() 或 throw() 方法时迭代器才会终止。</p>\n<h3>events.on() 开启一个 Node.js 服务器</h3>\n<p>之前一篇文章<a href=\"https://mp.weixin.qq.com/s/PNr-lQOGRGPHa-k-wXkV1A\">《“Hello Node.js” 这一次是你没见过的写法》</a>写过一段使用 events.on() 开启一个 HTTP 服务器的代码，在留言中当时有小伙伴对此提出疑惑，基于本章对异步迭代器在 events.on() 中使用的学习，可以很好的解释。</p>\n<p>相关代码如下所示：</p>\n<pre class=\"prettyprint language-javascript\"><code>import { createServer as server } from &#x27;http&#x27;;\nimport { on } from &#x27;events&#x27;;\nconst ee = on(server().listen(3000), &#x27;request&#x27;);\nfor await (const [{ url }, res] of ee)\n  if (url === &#x27;&#x2F;hello&#x27;)\n    res.end(&#x27;Hello Node.js!&#x27;);\n  else\n    res.end(&#x27;OK!&#x27;);\n</code></pre><p>以上代码看似新颖，其核心实现就是使用 events.on() 返回 createServer() 对象 request 事件的异步可迭代对象，之后用 <code>for await...of</code> 语句遍历，客户端每一次请求，就相当于做了一次 ee.emit(‘request’, Req, Res)。</p>\n<p>由于内部块的执行是同步的，下一次事件处理需要依赖上次事件完成才可以执行，对于一个 HTTP 服务器需要考虑并发的，请不要使用上面这种方式！</p>\n<h3>解析 Node.js 源码对 events.on 异步迭代器的实现</h3>\n<p>events 模块直接导出了 on() 方法，这个 on() 方法主要是将异步迭代器与事件的 EventEmitter 类的实例对象做了结合，实现还是很巧妙的，以下对核心源码做下解释，理解之后你完全也可以自己实现一个 events.on()。</p>\n<ul>\n<li>行 {1} ObjectSetPrototypeOf 是为对象设置一个新的原型，这个对象包含了 next()、return()、throw() 三个方法。</li>\n<li>行 {2} 根据异步可迭代协议，可迭代对象必须要包含一个 Symbol.asyncIterator 属性，该属性是一个无参数的函数，返回可迭代对象本身，也就是下面代码中 SymbolAsyncIterator。</li>\n<li>行 {3} 新的原型就是 ObjectSetPrototypeOf 的第二个参数 AsyncIteratorPrototype。</li>\n<li>行 {4} eventTargetAgnosticAddListener 是对事件注册监听器，里面还是用的事件触发器对象的 on() 方法 emitter.on(name, listener) 。</li>\n<li>行 {5} addErrorHandlerIfEventEmitter 判断事件名如果不等于 ‘error’ 同时注册一个 error 事件的监听器，具体实现同行 {4}。</li>\n<li>行 {6} eventHandler() 函数就是上面注册的监听器函数 listener 当有事件触发时执行该监听器函数，<strong>与异步迭代器的结合就在这里</strong>，当有新事件触发时会从 unconsumedPromises 数组里取出第一个元素执行，如果理解异步迭代器实现标准你会发现 PromiseResolve(createIterResult(args, false)) 就是异步迭代器对象 next() 方法返回值的标准定义。</li>\n<li>下面继续看 unconsumedPromises 从何而来。</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = EventEmitter;\nmodule.exports.on = on;\n\nfunction on(emitter, event) {\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  const iterator = ObjectSetPrototypeOf({ &#x2F;&#x2F; {1}\n    next() { .... },\n    return() { ... },\n    throw(err) { ... },\n    [SymbolAsyncIterator]() { &#x2F;&#x2F; {2}\n      return this;\n    }\n  }, AsyncIteratorPrototype); &#x2F;&#x2F; {3}\n  eventTargetAgnosticAddListener(emitter, event, eventHandler); &#x2F;&#x2F; {4}\n  if (event !== &#x27;error&#x27;) {\n    addErrorHandlerIfEventEmitter(emitter, errorHandler); &#x2F;&#x2F; {5}\n  }\n  return iterator;\n              \n  function eventHandler(...args) { &#x2F;&#x2F; {6}\n    const promise =  unconsumedPromises.shift();\n    if (promise) {\n      &#x2F;&#x2F; 以下等价于 promise.resolve({ value: args, done: false });\n      PromiseResolve(createIterResult(args, false));\n    } else {\n      &#x2F;&#x2F; for await...of 遍历器内部块的执行是同步的，所以每次只能处理 1 个事件，如果同时触发多个事件，上次事件未完成剩下的事件会被保存至 unconsumedEvents 中，待上次事件完成后，遍历器会自动调用 iterator 对象的 next() 方法，消费所有未处理的事件。\n      unconsumedEvents.push(args);\n    }\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  ...\n  emitter.on(name, listener);\n}\n</code></pre><p>以下是 iterator 对象的 next() 方法实现：</p>\n<ul>\n<li>行 {1} 首先消费未读消息</li>\n<li>行 {2} 判断如果是发生错误则抛出错误信息，例如 iterator 对象的 throw() 方法被调用后就会对 error 做赋值待下次遍历器调用 next() 此处代码就会被执行。</li>\n<li>行 {3} 如果迭代器对象完成，返回的 Promise 对象 done 属性设置为 true，遍历器也就结束了，变量 finished 是由 iterator 对象的 return() 方法被调用之后设置的。</li>\n<li>行 {4} <strong>这个是上面提到的 unconsumedPromises 数据来源处</strong>，例如当我们执行 <code>for await...of</code> 语句遍历异步迭代器对象时就会自动触发 iterator 对象的 next() 方法，执行到行 {4} 处会创建一个 Promise 对象但是 resolve 并没有被立即执行，而是先存放在 unconsumedPromises 数组中，所以在上面 <code>#events.on() 示例 2#</code> 提到一个问题，<strong><code>for await...of</code> 遍历事件的异步迭代器对象时后面的代码块并不会被执行，</strong> 当我们触发一个事件时才会在监听器函数里执行这个 resolve 函数，此时才会被释放，之后 <code>for await...of</code> 遍历器会自动再次执行 next() 方法，然后 new 一个新的 Promise 反复循环，直到事件对象抛出 error 事件或执行 iterator 对象的 return() 方法。</li>\n</ul>\n<pre class=\"prettyprint language-javascript\"><code>const iterator = ObjectSetPrototypeOf({\n  next() {\n    &#x2F;&#x2F; {1} 首先，我们会消费所有未读消息\n    const value = unconsumedEvents.shift();\n    if (value) {\n      return PromiseResolve(createIterResult(value, false));\n    }\n\n    &#x2F;&#x2F; {2} 如果发生一次 error 就会执行 Promise.reject 抛出一个错误，在这个错误发生后也会停止事件监听。\n    if (error) {\n      const p = PromiseReject(error);\n      &#x2F;&#x2F; Only the first element errors\n      error = null;\n      return p;\n    }\n\n    &#x2F;&#x2F; {3} 如果迭代器对象完成，Promise.resolve done 设置为 true\n    if (finished) {\n      return PromiseResolve(createIterResult(undefined, true));\n    }\n\n    &#x2F;&#x2F; {4} 等待直到一个事件发生\n    return new Promise(function(resolve, reject) {\n      unconsumedPromises.push({ resolve, reject });\n    });\n  }\n  ...\n}\n</code></pre><h2>在 Stream 中使用 asyncIterator</h2>\n<p>Node.js Stream 模块的可读流对象在 v10.0.0 版本试验性的支持了 <code>[Symbol.asyncIterator]</code> 属性，可以使用 <code>for await...of</code> 语句遍历可读流对象，在 v11.14.0 版本以上已 LTS 支持。</p>\n<h3>异步迭代器 与 Readable</h3>\n<p>借助 fs 模块创建一个可读流对象 readable。</p>\n<pre class=\"prettyprint language-javascript\"><code>const fs = require(&#x27;fs&#x27;);\nconst readable = fs.createReadStream(&#x27;.&#x2F;hello.txt&#x27;, {\n  encoding: &#x27;utf-8&#x27;,\n  highWaterMark: 1\n});\n</code></pre><p>以往当我们读取一个文件时，需要监听 data 事件，拼接数据，在 end 事件里判断完成，如下所示：</p>\n<pre class=\"prettyprint language-javascript\"><code>function readText(readable) {\n  let data = &#x27;&#x27;;\n  return new Promise((resolve, reject) =&gt; {\n    readable.on(&#x27;data&#x27;, chunk =&gt; {\n      data += chunk;\n    })\n    readable.on(&#x27;end&#x27;, () =&gt; {\n      resolve(data);\n    });\n    readable.on(&#x27;error&#x27;, err =&gt; {\n      reject(err);\n    });\n  })\n}\n</code></pre><p>现在通过异步迭代器能以一种更简单的方式实现，如下所示：</p>\n<pre class=\"prettyprint language-typescript\"><code>async function readText(readable) {\n  let data = &#x27;&#x27;;\n  for await (const chunk of readable) {\n    data += chunk;\n  }\n  return data;\n}\n</code></pre><p>现在我们可以调用 readText 做测试。</p>\n<pre class=\"prettyprint language-typescript\"><code>(async () =&gt; {\n  try {\n    const res = await readText(readable);\n    console.log(res); &#x2F;&#x2F; Hello Node.js\n  } catch (err) {\n    console.log(err.message);\n  }\n})();\n</code></pre><p><strong>使用 <code>for await...of</code> 语句遍历 readable，如果循环中因为 break 或 throw 一个错误而终止，则这个 Stream 也将被销毁</strong>。</p>\n<p>上述示例中 chunk 每次接收的值是根据创建可读流时 highWaterMark 这个属性决定的，为了能清晰的看到效果，在创建 readable 对象时我们指定了 highWaterMark 属性为 1 每次只会读取一个字符。</p>\n<h3>从 Node.js 源码看 readable 是如何实现的 asyncIterator</h3>\n<p>与同步的迭代器遍历语句 <code>for...of</code> 类似，用于 asyncIterator 异步迭代器遍历的 <code>for await...of</code> 语句在循环内部会默认调用可迭代对象 readable 的 Symbol.asyncIterator() 方法得到一个异步迭代器对象，之后调用迭代器对象的 next() 方法获取结果。</p>\n<p>本文以 Node.js 源码 v14.x 为例来看看源码是如何实现的。\n当我们调用 fs.createReadStream() 创建一个可读流对象时，对应的该方法内部会调用 ReadStream 构造函数</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;nodejs&#x2F;node&#x2F;blob&#x2F;v14.x&#x2F;lib&#x2F;fs.js#L2001\nfunction createReadStream(path, options) {\n  lazyLoadStreams();\n  return new ReadStream(path, options);\n}\n</code></pre><p>其实在 ReadStream 这个构造函数里没有我们要找的，重点是它通过原型的方式继承了 Stream 模块的 Readable 构造函数。</p>\n<pre class=\"prettyprint language-javascript\"><code>function ReadStream(path, options) {\n  ...\n  Readable.call(this, options);\n}\n</code></pre><p>那么现在我们重点来看看 Readable 这个构造函数的实现。</p>\n<p>Readable 原型上定义了 SymbolAsyncIterator 属性，该方法返回了一个由生成器函数创建的迭代器对象。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; for await...of 循环会调用\nReadable.prototype[SymbolAsyncIterator] = function() {\n  let stream = this;\n  ...\n  const iter = createAsyncIterator(stream);\n  iter.stream = stream;\n  return iter;\n};\n\n&#x2F;&#x2F; 声明一个创建异步迭代器对象的生成器函数\nasync function* createAsyncIterator(stream) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  const state = stream._readableState;\n\n  let error = state.errored;\n  let errorEmitted = state.errorEmitted;\n  let endEmitted = state.endEmitted;\n  let closeEmitted = state.closeEmitted;\n \n  &#x2F;&#x2F; error、end、close 事件控制了什么时候结束迭代器遍历。\n  stream\n    .on(&#x27;readable&#x27;, next)\n    .on(&#x27;error&#x27;, function(err) {\n      error = err;\n      errorEmitted = true;\n      next.call(this);\n    })\n    .on(&#x27;end&#x27;, function() {\n      endEmitted = true;\n      next.call(this);\n    })\n    .on(&#x27;close&#x27;, function() {\n      closeEmitted = true;\n      next.call(this);\n    });\n\n  try {\n    while (true) {\n      &#x2F;&#x2F; stream.read() 从内部缓冲拉取并返回数据。如果没有可读的数据，则返回 null\n      &#x2F;&#x2F; readable 的 destroy() 方法被调用后 readable.destroyed 为 true，readable 即为下面的 stream 对象\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk; &#x2F;&#x2F; 这里是关键，根据迭代器协议定义，迭代器对象要返回一个 next() 方法，使用 yield 返回了每一次的值\n      } else if (errorEmitted) {\n        throw error;\n      } else if (endEmitted) {\n        break;\n      } else if (closeEmitted) {\n        break;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    destroyImpl.destroyer(stream, err);\n    throw err;\n  } finally {\n    if (state.autoDestroy || !endEmitted) {\n      &#x2F;&#x2F; TODO(ronag): ERR_PREMATURE_CLOSE?\n      destroyImpl.destroyer(stream, null);\n    }\n  }\n}\n</code></pre><p>通过上面源码可以看到可读流的异步迭代器实现使用了生成器函数 Generator yield，那么对于 readable 对象遍历除了 <code>for await...of</code> 遍历之外，其实也是可以直接使用调用生成器函数的 next() 方法也是可以的。</p>\n<pre class=\"prettyprint language-javascript\"><code>const ret = readable[Symbol.asyncIterator]()\nconsole.log(await ret.next()); &#x2F;&#x2F; { value: &#x27;H&#x27;, done: false }\nconsole.log(await ret.next()); &#x2F;&#x2F; { value: &#x27;e&#x27;, done: false }\n</code></pre><h3>异步迭代器与 Writeable</h3>\n<p>通过上面讲解，我们知道了如何遍历异步迭代器从 readable 对象获取数据，但是你有没有想过如何将一个异步迭代器对象传送给可写流？正是此处要讲的。</p>\n<p><strong>从迭代器中创建可读流</strong></p>\n<p>Node.js 流对象提供了一个实用方法 stream.Readable.from()，对于符合 Symbol.asyncIterator 或 Symbol.iterator 协议的可迭代对象（Iterable）会先创建一个可读流对象 readable 之后从迭代器中构建 Node.js 可读流。</p>\n<p>以下是 <a href=\"https://mp.weixin.qq.com/s/UI3r3u50vYkrUTVe2DS86A\">从理解到实现轻松掌握 ES6 中的迭代器</a> 一文中曾讲解过的例子，r1 就是我们创建的可迭代对象。使用 stream.Readable.from() 方法则可以将可迭代对象构造为一个可读流对象 readable。</p>\n<pre class=\"prettyprint language-javascript\"><code>function Range(start, end) {\n  this.id = start;\n  this.end = end;\n}\nRange.prototype[Symbol.asyncIterator] = async function* () {\n  while (this.id &lt;= this.end) {\n    yield this.id++;\n  }\n}\nconst r1 = new Range(0, 3);\nconst readable = stream.Readable.from(r1);\nreadable.on(&#x27;data&#x27;, chunk =&gt; {\n  console.log(chunk); &#x2F;&#x2F; 0 1 2 3\n});\n</code></pre><p><strong>传送异步迭代器到可写流</strong></p>\n<p>使用 pipeline 可以将一系列的流和生成器函数通过管道一起传送，并在管道完成时获取通知。</p>\n<p>使用 util.promisify 将 pipeline 转化为 promise 形式。</p>\n<pre class=\"prettyprint language-javascript\"><code>const util = require(&#x27;util&#x27;);\nconst pipeline = util.promisify(stream.pipeline); &#x2F;&#x2F; 转为 promise 形式\n\n(async () =&gt; {\n  try {\n    const readable = stream.Readable.from(r1);\n    const writeable = fs.createWriteStream(&#x27;range.txt&#x27;);\n    await pipeline(\n      readable,\n      async function* (source) {\n        for await (const chunk of source) {\n          yield chunk.toString();\n        }\n      },\n      writeable\n    );\n    console.log(&#x27;Pipeline 成功&#x27;);\n  } catch (err) {\n    console.log(err.message);\n  }\n})()\n</code></pre><p>在写入数据时，传入的 chunk 需是 String、Buffer、Uint8Array 类型，否则 writeable 对象在写入数据时会报错。由于我们自定义的可迭代对象 r1 里最终返回的值类型为 Number 在这里需要做次转换，管道中间的生成器函数就是将每次接收到的值转为字符串。</p>\n<h2>在 MongoDB 中使用 asyncIterator</h2>\n<p>除了上面我们讲解的 Node.js 官方提供的几个模块之外，在 MongoDB 中也是支持异步迭代的，不过介绍这点的点资料很少，MongoDB 是通过一个游标的概念来实现的。</p>\n<h3>MongoDB 中的 cursor</h3>\n<p>本处以 Node.js 驱动 mongodb 模块来介绍，当我们调用 db.collection.find() 这个方法返回的是一个 cursor（游标），如果想要访问文档那么我们需要迭代这个游标对象来完成，但是通常我们会直接使用 toArray() 这个方法来完成。</p>\n<p>下面让我们通过一段示例来看，现在我们有一个数据库 example，一个集合 books，表里面有两条记录，如下所示：</p>\n<p><img src=\"//static.cnodejs.org/FjxP3_V6TDENlonLXRuJVl-iPyBI\" alt=\"image.png\"></p>\n<p>查询 books 集合的所有数据，以下代码中定义的 myCursor 变量就是游标对象，它不会自动进行迭代，可以使用游标对象的 hasNext() 方法检测是否还有下一个，如果有则可以使用 next() 方法访问数据。</p>\n<p>通过以下日志记录可以看到在第三次调用 hasNext() 时返回了 false，如果此时在调用 next() 就会报错，游标已关闭，也就是已经没有数据可遍历了。</p>\n<pre class=\"prettyprint language-javascript\"><code>const MongoClient = require(&#x27;mongodb&#x27;).MongoClient;\nconst dbConnectionUrl = &#x27;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;example&#x27;;\n\n(async () =&gt; {\n  const client = await MongoClient.connect(dbConnectionUrl, { useUnifiedTopology: true });\n  const bookColl = client.db(&#x27;example&#x27;).collection(&#x27;books&#x27;);\n  const myCursor = await bookColl.find();\n \n  console.log(await myCursor.hasNext()); &#x2F;&#x2F; true\n  console.log((await myCursor.next()).name); &#x2F;&#x2F; 深入浅出Node.js\n  console.log(await myCursor.hasNext()); &#x2F;&#x2F; true\n  console.log((await myCursor.next()).name); &#x2F;&#x2F; Node.js实战\n  console.log(await myCursor.hasNext()); &#x2F;&#x2F; false\n  console.log((await myCursor.next()).name); &#x2F;&#x2F; MongoError: Cursor is closed\n})()\n</code></pre><p>直接调用 next() 也可检测，如果还有值则返回该条记录，否则 next() 方法返回 null。</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log((await myCursor.next()).name);\nconsole.log((await myCursor.next()).name);\nconsole.log((await myCursor.next()));\n</code></pre><h3>MongoDB 异步迭代器实现源码分析</h3>\n<p>MongoDB 中游标是以 hasNext() 返回 false 或 next() 返回为 null 来判断是否达到游标尾部，与之不同的是在我们的 JavaScript 可迭代协议定义中是要有一个 Symbol.asyncIterator 属性的迭代器对象，且迭代器对象是 { done, value } 的形式。</p>\n<p>幸运的是 MongoDB Node.js 驱动已经帮助我们实现了这一功能，通过一段源码来看在 MongoDB 中的实现。</p>\n<ul>\n<li><strong>find 方法</strong></li>\n</ul>\n<p>find 方法返回的是一个可迭代游标对象。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mongodb&#x2F;node-mongodb-native&#x2F;blob&#x2F;3.6&#x2F;lib&#x2F;collection.js#L470\n\nCollection.prototype.find = deprecateOptions(\n  {\n    name: &#x27;collection.find&#x27;,\n    deprecatedOptions: DEPRECATED_FIND_OPTIONS,\n    optionsIndex: 1\n  },\n  function(query, options, callback) {\n    const cursor = this.s.topology.cursor(\n      new FindOperation(this, this.s.namespace, findCommand, newOptions),\n      newOptions\n    );\n\n    return cursor;\n  }\n);\n</code></pre><ul>\n<li>CoreCursor</li>\n</ul>\n<p>核心实现就在这里，这是一个游标的核心类，MongoDB Node.js 驱动程序中所有游标都是基于此，如果当前支持异步迭代器，则在 CoreCursor 的原型上设置 Symbol.asyncIterator 属性，返回基于 Promise 实现的异步迭代器对象，这符合 JavaScript 中关于异步可迭代对象的标准定义。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mongodb&#x2F;node-mongodb-native&#x2F;blob&#x2F;3.6&#x2F;lib&#x2F;core&#x2F;cursor.js#L610\n\nif (SUPPORTS.ASYNC_ITERATOR) {\n  CoreCursor.prototype[Symbol.asyncIterator] = require(&#x27;..&#x2F;async&#x2F;async_iterator&#x27;).asyncIterator;\n}\n</code></pre><pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;mongodb&#x2F;node-mongodb-native&#x2F;blob&#x2F;3.6&#x2F;lib&#x2F;async&#x2F;async_iterator.js#L16\n\n&#x2F;&#x2F; async function* asyncIterator() {\n&#x2F;&#x2F;   while (true) {\n&#x2F;&#x2F;     const value = await this.next();\n&#x2F;&#x2F;     if (!value) {\n&#x2F;&#x2F;       await this.close();\n&#x2F;&#x2F;       return;\n&#x2F;&#x2F;     }\n\n&#x2F;&#x2F;     yield value;\n&#x2F;&#x2F;   }\n&#x2F;&#x2F; }\n\n&#x2F;&#x2F; TODO: change this to the async generator function above\nfunction asyncIterator() {\n  const cursor = this;\n\n  return {\n    next: function() {\n      return Promise.resolve()\n        .then(() =&gt; cursor.next())\n        .then(value =&gt; {\n          if (!value) {\n            return cursor.close().then(() =&gt; ({ value, done: true }));\n          }\n          return { value, done: false };\n        });\n    }\n  };\n}\n</code></pre><p>目前是默认使用的 Promise 的形式实现的，上面代码中有段 <code>TODO</code>， Node.js 驱动关于异步迭代实现这块可能后期会改为基于生成器函数的实现，这对我们使用是没变化的.</p>\n<h3>使用 for await…of 遍历可迭代对象 cursor</h3>\n<p>还是基于我们上面的示例，如果换成 <code>for await...of</code> 语句遍历就简单的多了。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myCursor = await bookColl.find();\nfor await (val of myCursor) {\n  console.log(val.name);\n}\n</code></pre><p>在 MongoDB 中的聚合管道中使用也是如此，就不再做过多分析了，如下所示：</p>\n<pre class=\"prettyprint language-javascript\"><code>const myCursor = await bookColl.aggregate();\nfor await (val of myCursor) {\n  console.log(val.name);\n}\n</code></pre><p>对于遍历庞大的数据集时，使用游标它会批量加载 MongoDB 中的数据，我们也不必担心一次将所有的数据存在于服务器的内存中，造成内存压力过大。</p>\n<h3>传送 cursor 到可写流</h3>\n<p>MongoDB 游标对象本身也是一个可迭代对象（Iterable），结合流模块的 Readable.from() 则可转化为可读流对象，是可以通过流的方式进行写入文件。</p>\n<p>但是要注意 MongoDB 中的游标每次返回的是单条文档记录，是一个 Object 类型的，如果直接写入，可写流是会报参数类型错误的，因为可写流默认是一个非对象模式（仅接受 String、Buffer、Unit8Array），所以才会看到在 pipeline 传输的中间又使用了生成器函数，将每次接收的数据块处理为可写流 Buffer 类型。</p>\n<pre class=\"prettyprint language-javascript\"><code>const myCursor = await bookColl.find();\nconst readable = stream.Readable.from(myCursor);\nawait pipeline(\n  readable,\n  async function* (source) {\n    for await (const chunk of source) {\n      yield Buffer.from(JSON.stringify(chunk));\n    }\n  },\n  fs.createWriteStream(&#x27;books.txt&#x27;)\n);\n</code></pre><h2>Reference</h2>\n<ul>\n<li><a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_readable_symbol_asynciterator\">https://nodejs.org/dist/latest-v14.x/docs/api/stream.html#stream_readable_symbol_asynciterator</a></li>\n<li><a href=\"https://nodejs.org/dist/latest-v14.x/docs/api/events.html#events_events_on_emitter_eventname\">https://nodejs.org/dist/latest-v14.x/docs/api/events.html#events_events_on_emitter_eventname</a></li>\n<li><a href=\"https://docs.mongodb.com/manual/tutorial/iterate-a-cursor/index.html\">https://docs.mongodb.com/manual/tutorial/iterate-a-cursor/index.html</a></li>\n</ul>\n</div>","title":"探索异步迭代器在 Node.js 中的使用","last_reply_at":"2020-12-19T08:24:55.759Z","good":true,"top":false,"reply_count":0,"visit_count":256,"create_at":"2020-12-19T08:24:55.759Z","author":{"loginname":"Q-Angelo","avatar_url":"https://avatars0.githubusercontent.com/u/17956058?v=4&s=120"}},{"id":"5fdce3c70f99cb3fad5e385f","author_id":"5fdc5fc50f99cb58285e36e8","tab":"share","content":"<div class=\"markdown-text\"><p>8/2酷Q跑路后，使用Node.js开发的。最初是为了复活自己的机器人。\n目前内核已经完全稳定，并支持手机端大部分功能。\n之前论坛一直上不来。希望有更多的爱好者来一起完善社区和生态哦。</p>\n<p>项目地址：\n<a href=\"https://github.com/takayama-lily/oicq\">Github</a> <a href=\"https://www.npmjs.com/package/oicq\">npm</a></p>\n</div>","title":"新的开源QQ机器人平台","last_reply_at":"2020-12-18T17:15:51.478Z","good":false,"top":false,"reply_count":0,"visit_count":309,"create_at":"2020-12-18T17:15:51.478Z","author":{"loginname":"takayama-lily","avatar_url":"https://avatars3.githubusercontent.com/u/12014361?v=4&s=120"}},{"id":"5fa768fff9736b02ceadb73d","author_id":"555c31f6e684c4c8088a0c88","tab":"ask","content":"<div class=\"markdown-text\"><p>虽然cnodejs已经老了，但它的历史还是辉煌的，真心希望不要就这么没落了</p>\n</div>","title":"不知道我发这个话题会不会成为cnodejs上最后一个话题","last_reply_at":"2020-12-18T07:57:45.584Z","good":false,"top":false,"reply_count":6,"visit_count":605,"create_at":"2020-11-08T03:41:51.797Z","author":{"loginname":"gafish","avatar_url":"https://avatars2.githubusercontent.com/u/1989426?v=4&s=120"}},{"id":"5f8a622cf9736b02ceadb596","author_id":"5b85221808d0b0fb2d8e6c84","tab":"ask","content":"<div class=\"markdown-text\"><p>大咖们，nodejs生态有没有比较成熟的微服务框架推荐？？</p>\n</div>","title":"nodejs生态有没有比较成熟的微服务框架推荐？？","last_reply_at":"2020-12-18T07:08:40.900Z","good":false,"top":false,"reply_count":2,"visit_count":651,"create_at":"2020-10-17T03:17:00.461Z","author":{"loginname":"danielmlc","avatar_url":"https://avatars2.githubusercontent.com/u/16604995?v=4&s=120"}},{"id":"5f9637e7f9736b02ceadb62a","author_id":"5540cab1208c44bf37c24e3c","tab":"ask","content":"<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>灌水灌水\n</code></pre></div>","title":"估计现在都没有人","last_reply_at":"2020-10-26T13:07:55.460Z","good":false,"top":false,"reply_count":1,"visit_count":577,"create_at":"2020-10-26T02:43:51.454Z","author":{"loginname":"doxiaodong","avatar_url":"https://avatars3.githubusercontent.com/u/6927481?v=4&s=120"}},{"id":"5f79475972af8c02d3f8e513","author_id":"59aa89ea9e95202d08c91ed3","tab":"ask","content":"<div class=\"markdown-text\"><p>落伍了哦：（\n<a href=\"https://github.com/github/fetch/blob/master/fetch.js.flow\">https://github.com/github/fetch/blob/master/fetch.js.flow</a>\n中的代码：</p>\n<pre class=\"prettyprint language-typescript\"><code>type RequestOptions = {|\n  body?: ?BodyInit;\n  credentials?: CredentialsType;\n  headers?: HeadersInit;\n  method?: string;\n  mode?: string;\n  referrer?: string;\n  signal?: ?AbortSignal;\n|}\n</code></pre><p>上面的类型定义{| ……|}什么用？\nbody?: ?BodyInit; 第二个问号又作何解</p>\n<p>谢谢</p>\n</div>","title":".js.flow后缀文件是typescript？还是facebook搞出来的？","last_reply_at":"2020-10-10T01:32:34.961Z","good":false,"top":false,"reply_count":1,"visit_count":511,"create_at":"2020-10-04T03:54:01.421Z","author":{"loginname":"xinggsf","avatar_url":"https://avatars3.githubusercontent.com/u/13033798?v=4&s=120"}},{"id":"5f2138a6f0739b0e62d12b40","author_id":"5a3075929807389a1809f330","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://yggx.net/\">妹子这舞蹈跳的好看，主要是人长得好看</a>\n<a href=\"http://yggx.net\">yggx.net</a></p>\n</div>","title":"分享一个GIF图库 yggx.net","last_reply_at":"2020-10-09T01:46:10.808Z","good":false,"top":false,"reply_count":1,"visit_count":2824,"create_at":"2020-07-29T08:51:50.885Z","author":{"loginname":"varscc","avatar_url":"https://avatars3.githubusercontent.com/u/32264346?v=4&s=120"}},{"id":"5f7c74e3f9736b02ceadb432","author_id":"57c92f432adfc63a26784431","tab":"ask","content":"<div class=\"markdown-text\"><p>本站的dns解析挂了？</p>\n</div>","title":"本站的dns解析挂了？","last_reply_at":"2020-10-06T14:19:44.308Z","good":false,"top":false,"reply_count":3,"visit_count":657,"create_at":"2020-10-06T13:45:07.675Z","author":{"loginname":"Shonke","avatar_url":"https://avatars.githubusercontent.com/u/9344384?v=3&s=120"}},{"id":"5eeef3ea472c7975b04b69e3","author_id":"5eeef33913f8b244e57cabc5","tab":"share","content":"<div class=\"markdown-text\"><p>项目地址: <a href=\"https://github.com/davanchen/easytype\">https://github.com/davanchen/easytype</a></p>\n<h1>欢迎使用EasyType：一个基于TypeScript的动态类型反射系统</h1>\n<p>众所周知JavaScript因为语言的特性，无法与JAVA一样提供一种动态类型反射机制，而市面上又缺乏完善的解决方案，EasyType的出现是为了从根本上解决这个问题, 赋予开发者尤其是后端开发者更多的能力。</p>\n<h6>警告：单元测试未完全覆盖，切勿用于商业项目。</h6>\n<h6>开源只是为了交流技术、不想把一个好的理念埋没在个人手里，由于个人时间关系，本项目可能不会得到良好的维护，期望有成熟的公司或者团队能够改进或者重构它，让他成为node后端必备框架之一。</h6>\n<h3>项目起源</h3>\n<p>从18年开始，我就决定让团队使用node+typescript来开发后端服务，经过一年多的实践，发现各种库都有一套自己的“建模语言”来申明类型，比如mongoose、数据验证器、GraphQL、GRPC、swagger等等。这不禁让我迷惑不解，为什么用了typescript以后还要重复写这么多的类型申明？于是我从19年初开始开发了这个框架陆续来实现。刚开始是通过AST来分析mongoose的schema生成模型接口和定义，但是没有从根本上解决问题，所以接下来是通过直接分析typescript的类申明来实现，后续又引入了json-schema标准，最后对枚举、方法、联合类型、泛型都提供了支持。</p>\n<h3>设计目标</h3>\n<ul>\n<li>能够覆盖typescript绝大多数的类型，尤其是对泛型能提供完善的支持。</li>\n<li>尽可能的减少侵入，无需改动任何的代码</li>\n<li>支持Transpile模式，无需构建即可直接运行，而且编译速度非常快</li>\n<li>能够通过cli运行与构建项目,也能够脱离cli运行或者构建项目</li>\n</ul>\n<h3>方案对比</h3>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>对比</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://github.com/gcanti/io-ts\" title=\"io-ts\">io-ts </a></td>\n<td>定义了一套类型声明，设计目标可能主要是解决IO传输中的编码与解码</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/typestack/class-transformer\" title=\"class-transformer\">class-transformer</a></td>\n<td>定义了一套修饰器，只支持部分的TS类型</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/YousefED/typescript-json-schema\" title=\"typescript-json-schema\">typescript-json-schema</a></td>\n<td>需要调用CLI生成JSON格式的类型声明，非动态</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/goloveychuk/tsruntime\" title=\"tsruntime\">tsruntime</a></td>\n<td>是和typescript-json-schema一样在TypeCheck阶段实现，因此不支持Transpile模式</td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/andywer/type-reflect\" title=\"type-reflect\">type-reflect</a></td>\n<td>类似，但功能不够完善</td>\n</tr>\n</tbody>\n</table>\n<h3>使用场景</h3>\n<p>引入EasyType将为你的后端开发带来更大的想象空间，其中我们团队用到的部分就包括：</p>\n<ul>\n<li>不用添加任何代码，将TS类申明直接转换成mongoose schema</li>\n<li>不用添加任何代码，可以直接使用各种json-schema数据验证器</li>\n<li>不用添加任何代码，动态生成API文档，稍微改动就能生成OpenAPI规范的swagger文档，你的接口改动团队其他成员可以随时看到。</li>\n<li>不用添加任何代码，动态生成RPC声明，比如一键生成GRPC proto申明文件，把微服务开发变成一件很轻松的事情。</li>\n<li>由于后端能够输出完整的类型申明，因此前端（尤其是后台开发）能够快速的构建出数据显示、操作界面，会使开发变得更快速高效。</li>\n</ul>\n<h3>原理</h3>\n<p>通过typescript的自定义transform，在编译阶段把类型写入类描述中，最后在运行时生成json-schema标准的类型说明。</p>\n<pre class=\"prettyprint language-javascript\"><code>@Reflectable()\nexport class User extends Document {\n    &#x2F;** 用户ID *&#x2F;\n    uid: number;\n\n    &#x2F;** 用户名 *&#x2F;\n    username: string;\n}\n</code></pre><p>比如以上代码，通过编译器将变为:</p>\n<pre class=\"prettyprint language-javascript\"><code>export class User extends Document {\n    $easy.IsObject({\n        $type: 1,\n        $properties: {\n            uid: {\n                $type: 2,\n                $description: &quot;\\u7528\\u6237ID&quot;,\n                $ref: Number\n            },\n            username: {\n                $type: 2,\n                $description: &quot;\\u7528\\u6237\\u540D&quot;,\n                $ref: String\n            },\n        },\n        $target: User,\n        $id: &quot;User&quot;,\n        $extends: mongoose_1.Document\n    })\n    private $metadata: any;\n}\n</code></pre><p>通过在运行时调用 Schema.getMetadata(User), 即可得到User的类型声明(json-schema):</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;type&quot;: &quot;object&quot;,\n    &quot;properties&quot;: {\n        &quot;_id&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;format&quot;: &quot;OBJECT_ID&quot;,\n            &quot;description&quot;: &quot;ID&quot;\n        },\n        &quot;uid&quot;: {\n            &quot;type&quot;: &quot;number&quot;,\n            &quot;description&quot;: &quot;用户ID&quot;,\n        },\n        &quot;username&quot;: {\n            &quot;type&quot;: &quot;string&quot;,\n            &quot;description&quot;: &quot;用户名&quot;,\n        }\n    },\n    &quot;required&quot;: [\n        &quot;_id&quot;,\n        &quot;uid&quot;,\n        &quot;username&quot;\n    ],\n    &quot;$id&quot;: &quot;User&quot;,\n    &quot;$x&quot;: &quot;Document&quot;\n}\n</code></pre><h3>更强大的ENUM</h3>\n<p>在typescript中enum的存在更像是为了描述类型（你在运行时很难分清哪个是key,哪个是value），这也就不能与JAVA一样提供一些操作, 因此EasyType在编译阶段增加一些方法，使之变得更加灵活和强大，借助这些特性我们就能够实现无缝输出ENUM信息到API文档，而无需再书写任何的注释或者代码。</p>\n<pre class=\"prettyprint language-javascript\"><code>export interface EnumInterface&lt;T&gt; {\n    readonly keys: string[];\n\n    readonly values: number[] | string[];\n\n    getValue(key: string): Undefinable&lt;T&gt;;\n\n    hasValue(value: any): boolean;\n\n    getKeys(value: any): string[];\n\n    getKey(value: any): Undefinable&lt;string&gt;;\n\n    hasKey(key: string): boolean;\n\n    getDescription(key: string): Undefinable&lt;string&gt;;\n}\n\nexport type Enum&lt;T = any, V = number | string&gt; =\n    { readonly [P in keyof T]: T[P]; }\n    &amp; Readonly&lt;EnumInfo&gt;\n    &amp; EnumInterface&lt;V&gt;\n    ;\n\n</code></pre><p>现在你可以通过 Enum&lt;Foo&gt;.Keys 和 Enum&lt;Bar&gt;.values 获得键值，也可以拿到对应的像这样的类型申明：</p>\n<pre class=\"prettyprint language-javascript\"><code>    {\n        &quot;name&quot;: &quot;AssetType&quot;,\n        &quot;description&quot;: &quot;用户资产类型&quot;,\n        &quot;fields&quot;: [\n            {\n                &quot;key&quot;: &quot;BALANCE&quot;,\n                &quot;value&quot;: 1,\n                &quot;description&quot;: &quot;账户余额&quot;\n            },\n            {\n                &quot;key&quot;: &quot;POINTS&quot;,\n                &quot;value&quot;: 3,\n                &quot;description&quot;: &quot;账户积分&quot;\n            }\n        ]\n    },\n</code></pre><h3>部分继承</h3>\n<p>使用关键词extends会继承基类所有的属性，有时候如果你想部分继承基类属性，可以使用Inherits语法糖：</p>\n<pre class=\"prettyprint language-javascript\"><code>@Reflectable()\nexport class UserLoginDto implements Inherits&lt;User&gt; {\n    username: string;\n    password: string;\n}\n\n</code></pre><h3>方法反射</h3>\n<p>方法的注释、修饰符、参数、返回值等信息会被标注到Metadata中，可以通过 Reflect.getMetadata(‘easy:metadata’, target, propertyKey) 获取。</p>\n<h3>还有哪些问题？</h3>\n<ul>\n<li>还没来得及做完整的单元测试，所以暂时不能用于商业项目</li>\n<li>泛型目前编译器这块已完成，但是运行时由于时间关系还未能提供支持</li>\n<li>由于设计原因，只能支持类的输出，不支持interface和type的输出，因为前者在js运行时以function存在，后者不存在于运行时，或许后面会想办法支持。</li>\n<li>低版本的TypeScript（3.7以下）会有一些问题，所以用最新的TSC编译吧。</li>\n</ul>\n<h3>插播一条广告</h3>\n<p>即将推出基于EasyType+nest.js的全家桶开发包，尽情期待。\n项目地址: <a href=\"https://github.com/davanchen/easynest\">https://github.com/davanchen/easynest</a></p>\n<h3>演示：借助vscode插件(即将开源)一键生成proto</h3>\n<p><img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/Code_7GLTwoRGAx.png\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/Code_oBYASf68Uo.png\" alt></p>\n<h3>演示：EasyNest API文档模块自动生成API描述（枚举、控制器、模型）</h3>\n<p><img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_controller.PNG\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_enums.PNG\" alt>\n<img src=\"https://tmyx.oss-cn-hangzhou.aliyuncs.com/github/screenshot_models.PNG\" alt></p>\n</div>","title":"快来了解一下EasyType：开源的基于TypeScript的动态类型反射系统","last_reply_at":"2020-10-03T06:40:33.596Z","good":false,"top":false,"reply_count":9,"visit_count":5010,"create_at":"2020-06-21T05:45:14.647Z","author":{"loginname":"davanchen","avatar_url":"https://avatars2.githubusercontent.com/u/48879035?v=4&s=120"}},{"id":"5ce36eb4518e0954fc41015b","author_id":"5bc6779d37a6965f5905229a","tab":"ask","content":"<div class=\"markdown-text\"><p>各位前辈，之前有请教 ，使用权限管理框架，前辈介绍了casbin、shiro，请问有机会找到教学视频吗？付一些钱我也ok的，</p>\n<p>或是项目  的范例，谢谢</p>\n</div>","title":"各位前辈，之前有请教 ，使用权限管理框架，前辈介绍了casbin、shiro，请问有机会找到教学视频吗？付一些钱我也ok的，谢谢","last_reply_at":"2020-10-03T04:48:31.277Z","good":false,"top":false,"reply_count":9,"visit_count":3472,"create_at":"2019-05-21T03:21:24.314Z","author":{"loginname":"Solomonqoo","avatar_url":"https://avatars3.githubusercontent.com/u/44214486?v=4&s=120"}},{"id":"5f73ff3a72af8c02d3f8e1b1","author_id":"5cc281d7a86ae80ce64b445a","tab":"ask","content":"<div class=\"markdown-text\"><p>现在egg多个进程间对资源的争抢是怎么设计这个锁的呢？目前我们自己都是使用redis.incr来争抢某个key，值为1的进程就可以操作该资源，其他进程放弃操作或者循环等待。\n看到有博客提到Atomics这个模块，不知道egg中是否可以使用这个实现锁？</p>\n</div>","title":"egg多进程实现锁的最佳实践是什么？","last_reply_at":"2020-10-03T01:10:09.580Z","good":false,"top":false,"reply_count":5,"visit_count":611,"create_at":"2020-09-30T03:44:58.094Z","author":{"loginname":"974806047","avatar_url":"https://avatars3.githubusercontent.com/u/20623913?v=4&s=120"}},{"id":"53487b01b9b1b4047b000fb8","author_id":"51525d4a5dff253b3709382f","content":"<div class=\"markdown-text\"><p>RT</p>\n</div>","title":"Mongous 如何根据 _id 查询数据? 希望给个例子.","last_reply_at":"2020-10-02T03:40:17.620Z","good":false,"top":false,"reply_count":6,"visit_count":4236,"create_at":"2014-04-11T23:30:09.689Z","author":{"loginname":"gabacai81","avatar_url":"//gravatar.com/avatar/404dc6e8cf0755199b1381a5f2eeec0f?size=48"}}]}